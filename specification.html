<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="UTF-8" />

<!--***************************************************************

      AUTHORS: Miro Keller and collaborators

      COPYRIGHT: (c)2011 - All Rights Reserved

      LICENSE: see License.txt file

      WEB: http://axr.vg

      THIS CODE AND INFORMATION ARE PROVIDED "AS IS"
      WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR
      FITNESS FOR A PARTICULAR PURPOSE.

*******************************************************************

      FILE INFORMATION:
      =================
      Last changed: 2012/11/10
      HSS version: 1.0
      Revision: 1.52

****************************************************************-->

	<title>The AXR Specification</title>
	<meta name="author" content="Miro Keller, Marc G." />
    <style type="text/css">

	body
	{
		width: 720px;
		font-family: "Century Gothic", "Futura", "Verdana", sans-serif;
		margin: 30px auto;
		color: #666;
	}

	a[href^="#"], :local-link
	{
		-moz-text-decoration-line:underline;
		-moz-text-underline-style:dotted;
		-webkit-text-decoration-line:underline;
		-webkit-text-decoration-style:dotted;
	}

	.notice
	{
		margin: 20px auto;
		background-color: rgba(153,153,153,0.1);
		padding: 20px;
		border-radius: 15px
	}

	.notice p
	{
		margin: 5px 0;
	}

	.notice strong
	{
		color: red;
	}

	p.center, h1
	{
		text-align: center;
	}

	p > span
	{
		background: #fef3c8;
		padding: 0 2px;
		border: 1px solid #dca992;
		color: #b5471a;
		border-radius: 2px;
		font-family: monospace;
	}

	code, pre
	{
		background: #FEF3C8;
		padding: 20px;
		border: 1px solid #DCA992;
		color: #B5471A;
		border-radius: 2px;
		white-space: pre-wrap;       /* css-3 */
		white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
		white-space: -pre-wrap;      /* Opera 4-6 */
		white-space: -o-pre-wrap;    /* Opera 7 */
		word-wrap: break-word;
	}

	p code, ul code
	{
		padding: 0 2px;
	}

	section ul
	{
		list-style: circle outside;
	}

	.comment
	{
		color: #95877e;
	}

	.selector
	{
		color: #fd2f7a;
	}

	.property
	{
		color: #1b8a93;
	}

	.filter
	{
		color: #199013;
	}

	.combinator
	{
		color: #1e97f4;
	}

	.object
	{
		color: #933492;
	}

	.number
	{
		color: #2146fa;
	}

	.string
	{
		color: #fd2716;
	}

	.modifier
	{
		color: #000;
	}

	.instruction
	{
		color: #8A0067;
	}

	.flag
	{
		color: #8D8711;
	}

	.splitter
	{
		color: #E52A90;
	}

	pre .highlighted
	{
		background-color: #fefefe;
	}

	table
	{
		width: 100%;
		border: 1px solid #CCC;
	}

	table th
	{
		background-color: #CCC;
		padding: 10px;
	}


	table th:first-child
	{

	}

	table td
	{
		border: 1px solid #CCC;
		text-align: left;
		padding: 10px;
	}

	pre.xml
	{
		background-color: #d6fcd0;
		border-color: #5bac80;
		color: #498e68;
	}

	ul, #spec ol
	{
		list-style: inside;
		line-height: 1.4;
		margin: 10px;
	}

	ul li, ol li
	{
		color: #666666;
	}

	nav li
	{
		list-style:none;
		font-size:13px;
		line-height:18px;
	}

	nav li li
	{
		font-size:11px;
		line-height:15px;
	}

	nav > ul
	{
		counter-reset:section;
		background-color:#f5f7f6;
		margin:0 auto;
		padding:20px;
		-moz-column-count: 2;
		-moz-column-gap: 1em;
		-webkit-column-count: 2;
		-webkit-column-gap: 1em;
		column-count: 2;
		column-gap: 1em;
		height: 625px;
	}

	nav > ul > li
	{
		counter-reset:subsection;
	}

	nav > ul > li:before
	{
		counter-increment:section;
		content:"1." counter(section) " ";
	}

	nav ul ul > li:before
	{
		counter-increment:subsection;
		content:"1." counter(section) "." counter(subsection) " ";
	}

	nav li.hasSub ul
	{
		display:none;
	}
	nav li.hasSub:hover ul
	{
		display:block;
	}
	nav li.hasSub li
	{
		counter-increment:alpha;
	}
	nav li.hasSub li:before
	{
		counter-increment:none;
		content:"1." counter(section) "." counter(subsection) "." counter(alpha, upper-latin) " ";
	}

	.sub.yet:hover h4:after, .sub.part:hover h4:after, .sub.comp:hover h4:after
	{
		content:" [not supported yet]";
		font-weight:normal;
		font-size:xx-small;
		vertical-align:text-top;
	}
	.sub.part:hover h4:after
	{
		content:" [partially supported]"
	}
	.sub.comp:hover h4:after
	{
		content:" [supported]"
	}

	h5:before
	{
		content: "\2042\00A0";
		font-size:14px;
	}

	.subsec
	{
		color: #8e4dd0;
	}

	.subsec:before
	{
		content: "\00A7\00A0";
		font-size: 22px;
		font-weight: normal;
	}
	.subsec:after
	{
		display:none;
	}
	
	h4 span.number:hover:before, h3 span.number:hover:before
	{
		content:"\2735";
		font-size:32px;
		font-weight:normal;
		position:absolute;
		margin:-10px 0 0 -30px;
	}

	#btt
	{
		position:fixed;
		bottom:5px;
		right:5px;
		font-size:xx-small;
	}

	em.monospace
	{
	    font-family: monospace;
	    font-style: normal;
	}

	.compound-word
	{
	    background: none;
	    border: 0;
	    color: #666;
	    font-family: "Century Gothic", "Futura", "Verdana", sans-serif;
        padding: 0;
	    white-space: nowrap;
	}
	</style>
</head>
<body>
<div id="draft_warning" class="notice">
	<p><strong>Warning!</strong></p>
	<p>This file is an editor's draft and should not be considered final.</p>
</div>

<h1>Arbitrary XML Rendering Specification</h1>
<nav><a id="toc"></a>
<ul>
<li><a href="#n1.1">Introduction</a></li>
<li><a href="#n1.2">The primary building blocks</a>
	<ul>
	     <li><a href="#n1.2.1">Rules</a></li>
	     <li><a href="#n1.2.2">Selector basic principles</a></li>
	     <li><a href="#n1.2.3">Properties</a></li>
	     <li><a href="#n1.2.4">Objects</a></li>
	     <li><a href="#n1.2.5">HSS points</a></li>
	     <li><a href="#n1.2.6">The negator</a></li>
	</ul>
</li>
<li><a href="#n1.3">Selectors</a>
	<ul>
	     <li><a href="#n1.3.1">Element name</a></li>
	     <li><a href="#n1.3.2">Hierarchy &amp; Scope</a></li>
	     <li><a href="#n1.3.3">Grouping</a></li>
	     <li><a href="#n1.3.4">The universal selector</a></li>
	     <li><a href="#n1.3.5">Selecting the subject</a></li>
	     <li><a href="#n1.3.6">Regex selector</a></li>
	     <li><a href="#n1.3.7">Reference objects</a></li>
	</ul>
</li>
<li><a href="#n1.4">Combinators</a>
	<ul>
	     <li><a href="#n1.4.1">Child combinator</a></li>
	     <li><a href="#n1.4.2">Descendant combinator</a></li>
	     <li><a href="#n1.4.3">Siblings combinator</a></li>
	     <li><a href="#n1.4.4">Next and previous siblings combinators</a></li>
	     <li><a href="#n1.4.5">Accessing elements laid out in lines</a></li>
	     <li><a href="#n1.4.6">Content text combinator</a></li>
	     <li><a href="#n1.4.7">Ancestor combinator</a></li>
	</ul>
</li>
<li><a href="#n1.5">Filters, flags and splitters</a>
	<ul>
	     <li><a href="#n1.5.1">Position filters</a></li>
	     <li><a href="#n1.5.2">Hierarchy filters</a></li>
	     <li><a href="#n1.5.3">System flags</a></li>
	     <li><a href="#n1.5.4">The attribute filter</a></li>
	     <li><a href="#n1.5.5">Text matching filters</a></li>
	     <li><a href="#n1.5.6">Property filters</a></li>
	     <li><a href="#n1.5.7">Splitters</a></li>
	     <li><a href="#n1.5.8">Collection filters</a></li>
	     <li><a href="#n1.5.9">Custom macros</a></li>
	     <li><a href="#n1.5.10">User flags</a></li>
	     <li><a href="#n1.5.11">Object filter</a></li>
	</ul>
</li>
<li><a href="#n1.6">Properties</a>
	<ul>
	     <li><a href="#n1.6.1">Literal values</a></li>
	     <li><a href="#n1.6.2">Expressions</a></li>
	     <li class="hasSub"><a href="#n1.6.3">Functions</a>
	     <ul>
		<li><a href="#n1.6.3.a">Retrieval funtions</a></li>
		<li><a href="#n1.6.3.b">Type conversion functions</a></li>
		<li><a href="#n1.6.3.c">Arithmetic functions</a></li>
	     </ul>
	     </li>
	     <li><a href="#n1.6.4">Color</a></li>
	     <li><a href="#n1.6.5">Grouping</a></li>
	     <li><a href="#n1.6.6">The value selector</a></li>
	     <li><a href="#n1.6.7">Boolean casting</a></li>
	</ul>
</li>
<li><a href="#n1.7">Objects</a>
	<ul>
	     <li><a href="#n1.7.1">Object dot notation</a></li>
	     <li><a href="#n1.7.2">Named objects</a></li>
	     <li><a href="#n1.7.3">Anonymous objects</a></li>
	     <li><a href="#n1.7.4">Shorthand notation</a></li>
	     <li><a href="#n1.7.5">Grouping and inheritance</a></li>
	</ul>
</li>
<li><a href="#n1.8">Instructions</a>
	<ul>
	     <li><a href="#n1.8.1">Import</a></li>
	     <li><a href="#n1.8.2">Support</a></li>
	     <li><a href="#n1.8.3">Wrap</a></li>
	     <li><a href="#n1.8.4">Move</a></li>
	     <li><a href="#n1.8.5">New</a></li>
	</ul>
</li>
</ul>
</nav>
<div id="hss_syntax">
	<h2><span>1</span> The syntax of HSS</h2>
<section class="chapter">
		<h3><span class="number"><a href="#n1.1" id="n1.1">1.1</a></span> Introduction</h3>
		<p>HSS stands for Hierarchical Style Sheets and it is the language used to instruct the AXR renderer how the various elements in the document should look like, how they are laid out and, to some extent, how they behave. The syntax of this language is inspired in CSS, but extending and altering it in various ways, to achieve powerful new ways of creating a web document. Therefore, HSS is not compatible with existing CSS files.</p>
		<p class="center"><img src="http://static.axr.vg/images/spec/hss_logo.jpg" alt="Hierarchical Style Sheets Logo" /></p>
		<p>HSS inherits the simplicity and clarity of CSS‌' syntax, but stops being a static language, bearing more similarity in some areas to other programming languages. The primary premise for this is the realization that a web page isn‌'t a simple hyperlinked text document anymore, but an interactive software, which presents itself to the user through an interface and performs some logic, which may or not be displaying a text document. With this in mind, and the environment in which the document will be accessed (a computing device with an arbitrary display size), it is clear that some sort of interface programming language is needed which is able to express relationships and behaviors, and allows advanced interactivity and layout.</p><p>HSS files are plain-text files, and thus can be edited by any text editor on any platform, although some of its features are better put to use through a visual editing tool, since using code in those cases is less intuitive.</p>
</section>

<section class="chapter">
		<h3><span class="number"><a href="#n1.2" id="n1.2">1.2</a></span> The primary building blocks</h3>
		<h4><span class="number"><a href="#n1.2.1" id="n1.2.1">1.2.1</a></span> Rules</h4>
		<p>One of the most basic concepts in HSS is the notion of rules. A rule is the combination of a selector and a block, which starts with an opening curly brace <code>{</code> and ends with a closing one <code>}</code>, and may contain property definitions and/or other rules.</p>
<pre><span class="selector">selector</span>
{
	<span class="property">property</span>: value;
	<span class="selector">selector</span> { &#8230; }
}</pre>

		<h4><span class="number"><a href="#n1.2.2" id="n1.2.2">1.2.2</a></span> Selector basic principles</h4>
		<p><a href="#n1.3">Selectors</a> are used to point to certain elements of the document, so that the properties defined inside of the block get applied to them. You define a search pattern and all applicable elements will be searched to see if the conditions match. If so, the property definitions are applied.</p>
		<p>Simple selectors are the <a href="#n1.3.1">element names</a>, the <a href="#n1.3.4">universal selector</a> and <a href="#n1.3.7">reference objects</a>, combined with one or several appended <a href="#n1.5">filters, flags or splitters</a>. A series of simple selectors joined by <a href="#n1.4">combinators</a> is called the selector (or selector chain) and reads from left to right.</p>
		<p>Some examples:</p>
<pre><span class="comment">//select elements with name "document"</span>
<span class="selector">document</span> { }
<span class="comment">//select the first element with name "book"</span>
<span class="selector">book</span><span class="filter">:first</span> { }
<span class="comment">//select the elements with name "content" that occur after "title"
//elements, which are descendants of "book" elements, which themselves
//are direct children of "books" elements</span>
<span class="selector">books book</span> <span class="combinator">..</span> <span class="selector">title</span> <span class="combinator">+</span><span class="combinator"></span> <span class="selector">content</span> { }</pre>

		<h4><span class="number"><a href="#n1.2.3" id="n1.2.3">1.2.3</a></span> Properties</h4>
		<p>Each element in the document has a certain amount of <a href="#n1.6">properties</a>, which you can define using property definitions. They are contained within the block that follows a selector chain.</p>
		<p>A property declaration is composed of the name of the property, followed by optional whitespace, a colon and again optional whitespace, and finally either a literal value, an expression, a function or an object. More whitespace can come afterwards, as well. If it is not the last property declaration of the block, it must be ended by a semicolon, to denote that it finishes on that place, and that what follows is something else.</p>
		<p>Here are some examples:</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this makes it 150 <a href="#n1.2.5">points</a> wide</span>
    <span class="property">width</span>: <span class="number">150</span>;
    <span class="comment">//this makes the element 10 points less high than its parent's <a href="http://hss.axr.vg/@container#innerHeight">innerHeight</a></span>
    <span class="property">height</span>: <span class="number">100%</span> - <span class="number">10</span>;
    <span class="comment">//this aligns the element to the center of its parent element</span>
    <span class="property">alignX</span>: <span class="number">50%</span>;
    <span class="property">alignY</span>: <span class="number">50%</span>;
}

<span class="comment">//in this example the semicolon was omitted, since that
//property immediately precedes the closing brace</span>
<span class="selector">document</span> { <span class="property">alignX</span>: <span class="number">50%</span> }</pre>

		<h4><span class="number"><a href="#n1.2.4" id="n1.2.4">1.2.4</a></span> Objects</h4>
		<p><a href="#n1.7">Objects</a> represent values that are more complex in their nature. Similar to rules, objects have properties which accept values, defined inside a block. Objects are identified using the object sign <code>@</code> prefixed to their object type.</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this makes the element have rounded corners</span>
    <span class="property">shape</span>: <span class="object">@roundedRect</span> {
        <span class="property">corners</span>: <span class="number">5</span>;
    };
    <span class="comment">//this adds a simple border, 3 points wide and black in color</span>
    <span class="property">border</span>: <span class="object">@line</span> {
        <span class="property">size</span>: <span class="number">3</span>;
        <span class="property">color</span>: <span class="number">#000</span>;
    };
}</pre>

		<h4><span class="number"><a href="#n1.2.5" id="n1.2.5">1.2.5</a></span> HSS points</h4>
#TODO <a href="https://github.com/AXR/Specification/issues/68">Issue 68</a>
<div class="sub part">
		<h4><span class="number"><a href="#n1.2.6" id="n1.2.6">1.2.6</a></span> The negator</h4>
		<p>You can negate simple selectors by prefixing them with <code>!</code>, meaning that all elements in the current scope that don't match the selector will be selected.</p>
<pre><span class="comment">//this selects all elements except note ones</span>
<span class="modifier">!</span><span class="selector">note</span> { }</pre>
		<p>Likewise you can negate filters and flags.</p>
<pre><span class="comment">//this selects any note element which is not the first one</span>
<span class="selector">note</span><span class="modifier">!</span><span class="filter">:first</span> { }
<span class="comment">//this selects any note element which is not being hovered</span>
<span class="selector">note</span><span class="modifier">!</span><span class="flag">::hover</span> { }</pre>
		<p>To negate an entire selector (including its filters or flags) you have to use <a href="#square">grouping brackets</a>.</p>
<pre><span class="comment">//this matches all elements except the last note(s)</span>
<span class="modifier">!</span>[<span class="selector">note</span><span class="filter">:last</span>] {}</pre>
		<p>The negator can also be prepended to values.</p>
<pre><span class="selector">note</span>
{
    <span class="comment">//using a <a href="#n1.6.3.1">reference</a>, this ensures that the element
    //is not targetable when it is draggable
    //and targetable when it's not draggable</span>
    <span class="property">targetable</span>: <span class="modifier">!</span>ref(<span class="property">draggable</span>);
}</pre>
</div>
</section>

<section class="chapter">
		<h3><span class="number"><a href="#n1.3" id="n1.3">1.3</a></span> Selectors</h3>
		<p>Consider the following XML snippet:</p>
<pre class="xml">&lt;<span class="selector">note</span>&gt;
   &lt;<span class="selector">to</span>&gt;Peter&lt;/<span class="selector">to</span>&gt;
   &lt;<span class="selector">from</span>&gt;James&lt;/<span class="selector">from</span>&gt;
   &lt;<span class="selector">subject</span>&gt;Reminder&lt;/<span class="selector">subject</span>&gt;
   &lt;<span class="selector">message</span>&gt;Please don't forget to bring some &lt;<span class="selector">important</span>&gt;wine&lt;/<span class="selector">important</span>&gt;&#8230;&lt;/<span class="selector">message</span>&gt;
&lt;/<span class="selector">note</span>&gt;</pre>

		<p>In the following examples we will be using rules, but without property definitions for clarity. We will assume that this xml snippet could be inserted anywhere: the <em>note</em> element doesn't necessarily represent the root of the xml document.</p>
<div class="sub comp">
		<h4><span class="number"><a href="#n1.3.1" id="n1.3.1">1.3.1</a></span> Element name</h4>
		<p>You can target an element by its tag name.</p>
<pre><span class="comment">//match every note element (within the current scope) and apply
//the style rules declared within the block (in this case none)</span>
<span class="selector">note</span> { }</pre>
</div>
<div class="sub comp">
		<h4><span class="number"><a href="#n1.3.2" id="n1.3.2">1.3.2</a></span> Hierarchy &amp; Scope</h4>
		<p>Usually what the HSS author does is following the document tree and applying styles to most elements. Rules can be nested inside other rules which will only match children of the elements matched by the parent selector. This is what gives HSS its name.</p>
		<p>The scope refers to the elements targeted by the selector. In the following example, only message elements that are immediate children of note can be selected, because the scope is restricted to the children of the note element.</p>
<pre><span class="selector">note</span>
{
    <span class="comment">//match every message element which is a child
    //of the previously selected note element</span>
    <span class="selector">message</span> { }
}</pre>
#TODO <a href="https://github.com/AXR/Specification/issues/18">Issue 18</a>
<p>Similarly to avoid repetition you can nest the <a href="#n1.3.7.1">this object</a> affixed with filters or flags.</p>
<pre><span class="selector">note</span><br />{
    <span class="object">@</span><span class="flag">::hover</span> { }
}
<span class="comment">//which is equivalent to</span>
<span class="selector">note</span><br />{
    <span class="object">@this</span><span class="flag">::hover</span> { }
}
<span class="comment">//which is equivalent to</span>
<span class="selector">note</span> { }
<span class="selector">note</span><span class="flag">::hover</span> { }</pre>
</div>
<div class="sub part">
		<h4><span class="number"><a href="#n1.3.3" id="n1.3.3">1.3.3</a></span> Grouping</h4>
		<p>You can group multiple selectors together which is convenient when they share the same properties (or rules).</p>
<pre><span class="comment">//match the note's children of type subject and message</span>
<span class="selector">note</span> <span class="selector">subject</span>, <span class="selector">note</span> <span class="selector">message</span> { }</pre>
                <p>Selector grouping helps getting rid of unnecessary repetition.</p>
<pre>
<span class="comment">//hierarchical grouping</span>
note {
        child1, child2 {
                        element1, element2 { }
        }
}
<span class="comment">//which is equivalent to</span>
note { }
note child1, note child2 { }
note child1 element1, note child1 element2,
note child2 element1, note child2 element2 { }</pre>
		<p>Through the use of <a id="square">grouping brackets</a>, several consecutive parts of a selector chain can be evaluated as one.</p>
<pre><span class="comment">//inline grouping is also available</span>
note [child1, child2] [element1, element2] { }
<span class="comment">//which is equivalent to</span>
note child1 element1, note child1 element2,
note child2 element1, note child2 element2 { }

<span class="comment">//this could match B elements which precede A elements
//(which themselves are followed by C elements)</span>
[A + C] - B { }
<span class="comment">//which is equivalent to</span>
A + C - B { }
<span class="comment">//this couldn't: the B elements would have to come after an A
//and before a C</span>
A + [C - B] { }</pre>
		<p>You can also apply filters, flags or splitters to the aggregate resulting from the combined collections.</p>
<pre><span class="comment">//matches the odd element(s) of the collection of A1 and A2 elements</span>
[A1, A2]:odd { }
<span class="comment">//which is not equivalent to</span>
A1:odd, A2:odd { }</pre>
		<p>Grouping brackets can also be used to join collections of a simple selector.</p>
<pre><span class="comment">//this would join the collections of odd elements of each type
//and then out of that match the odd ones</span>
[<span class="selector">*</span><span class="splitter">/type</span><span class="filter">:odd</span>]<span class="filter">:odd</span> { }</pre>
</div>
<div class="sub comp">
		<h4><span class="number"><a href="#n1.3.4" id="n1.3.4">1.3.4</a></span> The universal selector</h4>
		<p>The universal selector <span class="selector">*</span> matches every element in the current scope:</p>
<pre><span class="comment">//matches every element that is a child of <em>note</em></span>
<span class="selector">note</span>
{
    <span class="selector">*</span> { }
}</pre>
<p><em>Reminder:</em> Since the initial scope is restricted to the root element, simply using the universal selector in the outermost rule set would only select one element, unlike what would happen in CSS. To traverse all scopes you need to start the selector chain with the <a href="#n1.4.2">descendant combinator</a>.</p>
<pre><span class="comment">//matches only the root element</span>
<span class="selector">*</span> { }
<span class="comment">//matches all elements under the root element</span>
<span class="selector">*</span> <span class="combinator">..</span> <span class="selector">*</span> { }
<span class="comment">//matches all elements</span>
<span class="combinator">..</span> <span class="selector">*</span> { }</pre>
<p>If the universal selector is not the only part of the selector, like when it has a filter, for example, it can be omitted. It may be omitted as well if placed between matching combinators (except the child and descendant combinators).</p>
<pre><span class="comment">//the following statements are equivalent</span>
<span class="selector">*</span><span class="filter">:first</span> { }
<span class="filter">:first</span> { }
<span class="comment">//and so are these</span>
<span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> { }
<span class="selector">*</span> <span class="combinator">&gt;&gt;</span> <span class="selector">*</span> { }</pre>
</div>
<div class="sub yet">
		<h4><span class="number"><a href="#n1.3.5" id="n1.3.5">1.3.5</a></span> Selecting the subject</h4>
		<p>Using the subject selector <code>$</code> you can match an element anywhere in the selector chain thus turning everything that follows it into a condition.</p>
<pre><span class="comment">//matches all note elements which have at least one comment element as a child</span>
<span class="modifier">$</span><span class="selector">note</span><span class="combinator"> </span><span class="selector">comment</span> { }
<span class="comment">//matches the note element which has an <em>important</em>
//descendant currently being hovered</span>
<span class="modifier">$</span><span class="selector">note</span> <span class="combinator">..</span> <span class="selector">important</span><span class="flag">::hover</span> { }</pre>
</div>
<div class="sub yet">
		<h4><span class="number"><a href="#n1.3.6" id="n1.3.6">1.3.6</a></span> Regex selector</h4>
		<p>You can use a regular expression to select elements based on their names.</p>
<pre><span class="comment">//matches every element in the current scope whose name starts with a number</span>
<span class="selector">/^[0-9]/</span> { }</pre>
</div>
<div class="sub part">
		<h4 class="title"><span class="number"><a href="#n1.3.7" id="n1.3.7">1.3.7</a></span> Reference Objects</h4>
		<p>The <a href="#n1.3.7.1" id="n1.3.7.1"><strong>this object</strong></a> always refers to the nearest container(s); independently of each other (if there are several matches). It can be used in a selector or a property's value.</p>
<pre><span class="comment">//using the <a href="#n1.7.1">object dot notation</a>, this would set the width
//to the element's <strong>current</strong> <em>computed</em> height value</span>
<span class="selector">element</span>
{
    <span class="property">height</span>: 100%;
    <span class="property">width</span>:  @this.height;
}</pre>
		<p>The <a href="#n1.3.7.2" id="n1.3.7.2"><strong>self object</strong></a> refers to the current object which immediately contains it. It is especially useful with <a href="#n1.7.3">anonymous objects</a>.</p>
<pre><span class="comment">//this would set the pattern's width value to the current
//pattern's height <em>computed</em> value</span>
<span class="object">@pattern</span>
{
    <span class="property">height</span>: 100%;
    <span class="property">width</span>:  @self.height;
}</pre>
		<p>The <a href="#n1.3.7.3" id="n1.3.7.3"><strong>root object</strong></a> refers to the topmost element, the one that encloses all others (excluding the viewport). This element is also the canvas, where all the other elements are drawn.</p>
<pre><span class="comment">//this sets the width of the <em>section</em> element(s)
//to the same value as the width of the root element
//if it is named "document"</span>
<span class="combinator">..</span> <span class="selector">section</span>
{
    <span class="property">width</span>: ref(<span class="property">width</span> of <span class="object">@root</span><span class="filter">:is(document)</span>);
}</pre>
		<p>The <a href="#n1.3.7.4" id="n1.3.7.4"><strong>parent object</strong></a> refers to the parent of the preceding element in the selector chain or (if there's none before) to the parent of the element which is currently affected by the styling rule containing <span class="object">@parent</span>.</p>
<pre><span class="comment">//set the messages' width to a third of their own parents' height</span>
<span class="combinator">..</span> <span class="selector">message</span>
{
    <span class="property">width</span>: ref(<span class="property">height</span> of <span class="object">@parent</span>) / <span class="number">3</span>;
}
<span class="comment">//this reference would return nothing (the root element doesn't have a parent)</span>
<span class="selector">@root</span>
{
    <span class="property">height</span>: ref(<span class="property">height</span> of <span class="object">@parent</span>);
}</pre>
		<p>The <a href="#n1.3.7.5" id="n1.3.7.5"><strong>these object</strong></a> refers to the nearest container(s) as a whole. It is particularly useful in case the rightmost selector is unknown.</p>
<pre><span class="object">@container</span> maxHeight
{
    <span class="comment">//this sets the height of the elements matched
    //to the height of whichever is currently the tallest</span>
    <span class="property">height</span>: ref(<span class="modifier">max</span> <span class="property">height</span> of <span class="selector">@these</span>);
}</pre>
		<p>The <a href="#n1.3.7.6" id="n1.3.7.6"><strong>owner object</strong></a> refers to the object or element which immediately contains the current object. It's designed to retrieve values from varying or multiple owners.</p>
#TODO example
</div>
</section>
<section class="chapter">
		<h3 class="title"><span class="number"><a href="#n1.4" id="n1.4">1.4</a></span> Combinators</h3>
		<p>Combinators allow you to select an element based on its relationship to another in the hierarchy. Multiple simple selectors can be chained together, forming the selector chain. Usually this is done when you want to "skip" the elements which leads to the one you want to style. In the case of a single childhood relationship, it is more convenient to use the child combinator than to nest rules; in other cases, combinators are mandatory regardless.</p>
<pre><span class="comment">//even in a hierarchical context
//you can start a selector chain by a combinator</span>
<span class="selector">note</span>
{
    <span class="comment">//this matches <em>important</em> elements which are descendants of <em>note</em> elements</span>
    <span class="combinator">..</span> <span class="selector">important</span> { }
}
<span class="comment">//which is equivalent to</span>
<span class="selector">note</span> { }
<span class="selector">note</span> <span class="combinator">..</span> <span class="selector">important</span> { }</pre>
<p>Keep in mind that these examples only select elements in the current scope, and therefore will select elements depending on where in the hierarchy you are using them.</p>
<div class="sub comp">
		<h4 class="title"><span class="number"><a href="#n1.4.1" id="n1.4.1">1.4.1</a></span> Child combinator</h4>
		<p>Children&#8212;or more explicitly level one descendants&#8212;may be selected using the child combinator (whitespace)&#160;<span class="combinator"> </span>.</p>
		<p><em>Note:</em> This is different from CSS, where the whitespace represents the descendant combinator. The reasoning behind this is that authors are inherently lazy, and thus end up using the descendant combinator when they really should be using the child combinator instead, because it's just much more convenient.</p>
<pre><span class="comment">//matches every subject element which is a child of note</span><br /><span class="selector">note subject</span> { }</pre>
</div>
<div class="sub comp">
		<h4 class="title"><span class="number"><a href="#n1.4.2" id="n1.4.2">1.4.2</a></span> Descendant combinator</h4>
		<p>If you want to select elements which are descendants (could be direct children of the element, or more generations down), the descendant combinator <span class="combinator">..</span> is used.</p>
<pre><span class="comment">//matches every subject element which is a descendant of note</span><br /><span class="selector">note</span> <span class="combinator">..</span> <span class="selector">subject</span> { }</pre>
</div>
<div class="sub part">
		<h4 class="title"><span class="number"><a href="#n1.4.3" id="n1.4.3">1.4.3</a></span> Siblings combinator</h4>
		<p>Sibling elements can be accessed via the siblings combinator <span class="combinator">=</span>:</p>
<pre><span class="comment">//matches all the subject elements that are siblings of<br />//the message element(s)</span><br /><span class="selector">message</span> <span class="combinator">=</span> <span class="selector">subject</span> { }</pre>
</div>
<div class="sub comp">
		<h4 class="title"><span class="number"><a href="#n1.4.4" id="n1.4.4">1.4.4</a></span> Next and previous siblings combinators</h4>
		<p>Use the next siblings combinator <span class="combinator">+</span> and previous siblings combinator <span class="combinator">-</span> if you want to access elements following or preceding (in the <em>current</em> tree order) a specified element in the same scope.</p>
<pre><span class="comment">//this will match the message element(s) following a from sibling</span>
<span class="selector">from</span> <span class="combinator">+</span> <span class="selector">message</span> { }
<span class="comment">//this will match the subject element(s) preceding a message sibling</span>
<span class="selector">message</span> <span class="combinator">-</span> <span class="selector">subject</span> { }</pre>
		<p><em>Note:</em> For further instructions on how to select amongst the following or preceding elements read the <a href="#n1.5">filters, flags and splitters</a> chapter.</p>
</div>
<div class="sub yet">
		<h4 class="title"><span class="number"><a href="#n1.4.5" id="n1.4.5">1.4.5</a></span> Accessing elements laid out in lines</h4>
		<p><strong>Note:</strong> This section is just the explanation of the very basic idea, and may change soon.</p>
		<p>Containers that are in flow might be laid out in various lines and subjacent line(s) of elements (see Layout of elements in Flow). You can target them by the use of the line combinator.</p><p>It works very similarly to how the <a href="#n1.4.6">content text combinator</a> works, but the line combinator uses the vertical bar <span class="combinator">|</span> instead. Placing a pipe selects the lines of elements in a container, selecting as many as you define with the next simple selector. </p>
#TODO link "Layout of elements in Flow"
<pre><span class="comment">//this will select all the lines of elements inside of the
//document element</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="selector">*</span> { }
<span class="comment">//this will select only the first line</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="filter">:first</span> { }</pre><p>If you place more pipes, you will drill down into the secondary lines (hierarchically) that have been formed according to the layout algorithm. As before, the universal selector can be omitted between the combinators.</p>
<pre><span class="comment">//this will select all the subjacent lines</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="selector">*</span> <span class="combinator">|</span> <span class="selector">*</span> { }<span class="comment">
//this is equivalent</span>
<span class="selector">document</span> <span class="combinator">||</span> <span class="selector">*</span> { }
<span class="comment">//this will select all the subjacent lines inside of the first
//line of elements</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="filter">:first</span> <span class="combinator">|</span> <span class="selector">*</span> { }</pre>
#TODO <a href="https://github.com/AXR/Specification/issues/37">Issue 37</a>
		<p>Since each line is a somewhat abstract concept - there is no element representing each line, if you create new elements in the scope of a line, only one element per line will be created, and not one per selected element, and it will be attached to the parent element. On the other hand, properties applied in the scope of the line will be applied to all elements in that line. </p><p>The <a href="#n1.3.7.4">parent object</a> will refer to the parent line, in case of a subjacent line, or the parent element, in case of a line.</p>
</div>
<div class="sub yet">
		<h4 class="title"><span class="number"><a href="#n1.4.6" id="n1.4.6">1.4.6</a></span> Content text combinator</h4>
		<p>Many times you will want to access a part of an element's content text&#8212;a word, or a particular line, for example&#8212;rather than its container.</p><p>Consider this snippet of XML code:</p>
<pre class="xml">&lt;<span class="selector">document</span>&gt;
    &lt;<span class="selector">paragraph</span>&gt;This is a line of dummy text. Lorem ipsum
    dolor sit amet, consectetur adipiscing elit.&lt;/<span class="selector">paragraph</span>&gt;
&lt;/<span class="selector">document</span>&gt;</pre>
		<p>First, we have to understand what happens with the content text when it is rendered. An element is represented by a container, think of it as an amount of space in the rendered document and inside it the content text and the containing elements. The default height of the container is the height of its content.</p>
		<p>When the width of the container is not wide enough to accommodate all its content text, wrapping occurs. This means that the text is split in various lines of text, and therefore the height increases. Now there are two or more blocks stacked over each other.</p>
		<p>Conceptually, the text can be further split into elements. Each word is preceded, followed, or surrounded by whitespace. Furthermore, each character (letter, kanji&#8230;) of that word is a separate glyph you can refer to.</p>
		<p><img alt="Graphic explaining the concept of lines, words and glyphs" src="http://static.axr.vg/images/spec/accessing_content_text.png" /></p>
		<p>To select portions of text, the content text combinator is used. After the combinator, you write a string to specify what part of the text you want to select.</p>
<pre><span class="comment">//this will select any occurrence of "dummy text" and set
//its height to 15 points</span>
<span class="combinator">..</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="string">"dummy text"</span> { <span class="property">height</span>: <span class="number">15</span> }
<span class="comment">//this will only match the first one</span>
<span class="combinator">..</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="string">"dummy text"</span><span class="filter">:first</span> { <span class="property">height</span>: <span class="number">15</span> }</pre>
		<p>The universal selector permits to select text elements by type (lines, words or glyphs):</p>
<pre><span class="comment">//this will select all lines (the entire content text)</span>
<span class="selector">document</span> <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span> { }
<span class="comment">//this will select the first line of text</span>
<span class="selector">document</span> <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:first</span> {}</pre>
		<p>To access a word, you use the content text combinator and universal selector again, after selecting a portion of the text:</p>
<pre><span class="selector">document</span>
{
&#160;&#160;&#160; <span class="comment">//this will select the last word of the content text</span>
&#160;&#160;&#160; <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:last</span> { }
&#160;&#160;&#160; <span class="comment">//this is equivalent, since the universal selector can be
&#160;&#160;&#160; //omitted in this case</span>
&#160;&#160;&#160; <span class="selector">paragraph</span> <span class="combinator">&gt;&gt;</span> <span class="filter">:last</span> { }
}</pre>
		<p>You repeat the same pattern again to select a glyph:</p>
<pre><span class="selector">document</span>
{
&#160;&#160;&#160; <span class="comment">//this will select the first letter of the content text</span>
&#160;&#160;&#160; <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:first</span> { }
&#160;&#160;&#160; <span class="comment">//this is equivalent</span>
&#160;&#160;&#160; <span class="selector">paragraph</span> <span class="combinator">&gt;&gt;&gt;</span> <span class="filter">:first</span> { }
}</pre>
		<p>The <a href="#s_each">each splitter</a> permits the separation of each text elements (either lines, words or glyphs) that would otherwise be joined in the same selection:</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this will select each line of text and give it vertical margins,
    //increasing the line spacing</span>
    <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="splitter">/each</span> { <span class="property">margin</span>: @{ <span class="property">top</span>, <span class="property">bottom</span>: <span class="number">5</span> }; }
    <span class="comment">//this will select the first three letters of "dummy", each separately</span>
    <span class="selector">paragraph</span> <span class="combinator">&gt;&gt;</span> <span class="string">"dummy"</span> <span class="combinator">&gt;</span> <span class="filter">:nth</span>(<span class="number">1</span>, <span class="number">3</span>)<span class="splitter">/each</span> { }
}</pre>
</div>
<div class="sub yet">
		<h4 class="title"><span class="number"><a href="#n1.4.7" id="n1.4.7">1.4.7</a></span> Ancestor combinator</h4>
		<p>Ancestors can be selected using the ancestor combinator <code>&lt;&lt;</code>. If the elements matched previously don't share the same ancestors, the combined collection of ancestors&#8212;and not the common ones&#8212;will be returned.</p>
<pre><span class="comment">//matches every ancestors of <em>important</em> elements</span>
<span class="combinator">..</span> <span class="selector">important</span> <span class="combinator">&lt;&lt;</span> <span class="selector">*</span> { }</pre>
</div>
</section>
<section class="chapter">
		<h3 class="title"><span class="number"><a href="#n1.5" id="n1.5">1.5</a></span> Filters, flags and  splitters</h3>
		<p><strong>Filters</strong> are used to reduce or alter the current selection. Each individual element of the selection is checked to see if the condition(s) match(es).</p>
		<p>Always remember that if used alone, the omitted universal selector is actually assumed. Filters can be appended to any other selector even allowing multiple affixed filters. For example, you could do the following:</p>
<pre><span class="comment">//this matches the first occurrence of the note element,
//if it has a child</span>
<span class="selector">note<span class="filter">:first:parent</span></span> { }</pre>
		<p>Keep in mind that the order of the filters will alter the outcome, so if you put the filters of the previous example in reverse order, it will select the <em>first element that has a child</em>, instead of the <em>first element, but only if it has a child</em>.</p>
<pre><span class="comment">//this matches the first of the note elements that have a child</span>
<span class="selector">note<span class="filter">:parent:first</span></span> { }</pre>
		<p>Using <strong>flags</strong> you can apply certain HSS declarations depending on an element's event state. Flags are preceded by <code>::</code> unlike filters which use <code>:</code>.</p>
		<p><em>Note:</em> <a href="#n1.5.3">System flags</a> are automatically activated and deactivated: the user has no control over their default behaviour.</p>
		<p>This XML sample will be used to illustrate examples throughout this chapter.</p>

<pre class="xml">&lt;<span class="selector">notes</span>&gt;
	&lt;<span class="selector">note</span>&gt;
		&lt;<span class="selector">to</span>&gt;Peter&lt;/<span class="selector">to</span>&gt;
		&lt;<span class="selector">from</span>&gt;James&lt;/<span class="selector">from</span>&gt;
		&lt;<span class="selector">subject</span>&gt;Reminder&lt;/<span class="selector">subject</span>&gt;
		&lt;<span class="selector">message</span>&gt;The keys are under the doormat.&lt;/<span class="selector">message</span>&gt;
		&lt;<span class="selector">message</span>&gt;Please don't forget to bring some wine.&lt;/<span class="selector">message</span>&gt;
	&lt;/<span class="selector">note</span>&gt;
	&lt;<span class="selector">note</span>&gt;
		&lt;<span class="selector">to</span>&gt;Paul&lt;/<span class="selector">to</span>&gt;
		&lt;<span class="selector">from</span>&gt;Julia&lt;/<span class="selector">from</span>&gt;
		&lt;<span class="selector">subject</span>&gt;Rendezvous&lt;/<span class="selector">subject</span>&gt;
		&lt;<span class="selector">message</span>&gt;Meet me at the inn.&lt;/<span class="selector">message</span>&gt;
	&lt;/<span class="selector">note</span>&gt;
&lt;/<span class="selector">notes</span>&gt;</pre>
<div class="sub part">
		<h4 class="title"><span class="number"><a href="#n1.5.1" id="n1.5.1">1.5.1</a></span> Position filters</h4>
		<p>The following filters are used to select a subset of elements, depending on their position in the <em>current</em> tree order.</p>
		<p>In the case of several matched parents the filters refer to the <strong>combined collection</strong> returned whereas their <em class="monospace">Child</em> variant to the children's position <strong>inside their own parent</strong>.</p>

		<p>The <strong><a id="f_first">first and firstChild filters</a></strong> match the first element(s).</p>
<pre><span class="comment">//this matches the first <em>to</em> element in our example</span>
notes note <span class="filter">:first</span> { }
<span class="comment">//this matches the first <em>to</em> elements of each <em>note</em> element in our example</span>
notes note <span class="filter">:firstChild</span> { }
<span class="comment">//which is equivalent to appending the <a href="#s_each">each splitter</a> to the former</span>
notes note <span class="splitter">/each</span><span class="filter">:first</span> { }</pre>
		<p>The <strong><a id="f_last">last and lastChild filters</a></strong> match the last element(s).</p>
<pre><span class="comment">//this matches the last element in the second <em>note</em> element</span>
notes note <span class="filter">:last</span> { }
<span class="comment">//this matches the last element<u>s</u> of each <em>note</em> element</span>
notes note <span class="filter">:lastChild</span> { }</pre>
		<p>The <strong><a id="f_even">even and evenChild filter</a></strong> select elements whose index is even (the count starts with 1).</p>
<pre><span class="comment">//in our example this matches the <em>from</em> element in the first <em>note</em> element
//but not the one in the second <em>note</em> element (7 isn't even)</span>
notes note from<span class="filter">:even</span> { }
<span class="comment">//in our example this matches the fourth <em>message</em> element<u>s</u> of the <em>note</em> elements</span>
notes note message<span class="filter">:evenChild</span> { }</pre>
		<p>The <strong><a id="f_odd">odd and oddChild filters</a></strong> select elements whose index is odd (the count starts with 1).</p>
<pre><span class="comment">//this matches the 1st <em>to</em> element in our example</span>
notes note to<span class="filter">:odd</span> { }
<span class="comment">//this matches the 1st <em>to</em> elements of each <em>note</em> element in our example</span>
notes note to<span class="filter">:oddChild</span> { }</pre>
		<p>The <strong><a id="f_nth">nth and nthChild filters</a></strong> select elements which index matches a number or expression, meets a condition or falls within a given range.</p>
<pre><span class="comment">//this matches the fourth element in the collection</span>
<span class="filter">:nth</span>(<span class="number">4</span>) { }
<span class="comment">//if there are at least 6 elements currently in the collection,
//it matches the element after every 5th one; if not it matches the 5th one</span>
<span class="filter">:nth</span>(5n + 1 | <span class="number">5</span>) { }
<span class="comment">//this matches elements whose index is &#8805; 3 in the collection</span>
<span class="filter">:nth</span>(&gt;= <span class="number">3</span>) { }
<span class="comment">//this matches elements whose index is 5, 10 or 15 in the collection</span>
<span class="filter">:nth</span>(5n, <span class="number">15</span>) { }
<span class="comment">//this matches elements whose index is 1, 2, 3 and &#8805; 8 in the collection</span>
<span class="filter">:nth</span>(<span class="number">1</span>, <span class="number">3</span> &amp; <span class="number">8</span>, *) { }</pre>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.2" id="n1.5.2">1.5.2</a></span> Hierarchy filters</h4>
		<p>You can filter elements by their relationship with the other elements in the tree.</p>
		<p>The <strong>parent filter</strong> matches every element that is a parent, which means that it has at least one child. If the element is an ancestor it will always also be a parent.</p>
<pre><span class="comment">//this matches childless elements</span>
<span class="modifier">!</span><span class="filter">:parent</span> { }</pre>
		<p>The <strong>has filter</strong> matches elements which have certain children, descendants or siblings.</p>
<pre><span class="comment">//this matches elements that are parent of at least one <em>message</em> element</span>
<span class="filter">:has</span>(<span class="selector">message</span>) { }
<span class="comment">//this matches elements that are an ancestor of a <em>message</em> element</span>
<span class="filter">:has</span>(<span class="selector">.. message</span>) { }
<span class="comment">//this matches elements which have at least one <em>message</em> sibling preceding them</span>
<span class="filter">:has</span>(<span class="selector">- message</span>) { }</pre>
</div>
<div class="sub part">
<h4 class="title"><span class="number"><a href="#n1.5.3" id="n1.5.3">1.5.3</a></span> System flags</h4>
<p>You usually want to provide some kind of feedback to the user when he/she is using your site. Targeting elements using flags is an easy way to add interactivity to the site, to create a compelling user experience.</p>
<p>The <strong>hover flag</strong> targets only elements that are lying under the cursor.</p><pre><span class="comment">//matches every element which has the mouse over it (even overlaid ones)</span>
<span class="flag">::hover</span> { }</pre>
<p>The <strong>press flag</strong> targets only elements which are lying under the mouse pointer while the primary button is pressed (usually the left one) or during an hold event (an unreleased touch event).</p><pre><span class="comment">//matches every element which is being pressed</span>
<span class="flag">::press</span> { }</pre>
<p>The <strong>drag flag</strong> targets only elements which are being dragged (multiple elements can be dragged at the same time using a multi-touch interface device).</p><pre><span class="comment">//matches every element that is being dragged</span>
<span class="flag">::drag</span> { }</pre>
<p>The <strong>target flag</strong> targets elements which are a potential landing point for the currently dragged element(s).</p>
<pre><span class="comment">//matches all elements that are actual dragging destination
//for the currently dragged element(s)</span>
<span class="flag">::target</span> { }
<span class="comment">//which is equivalent to</span>
<span class="flag">::target(*)</span> { }
<span class="comment">//this will match while a <em>file</em> sibling is being dragged</span>
<span class="flag">::target(file)</span> { }</pre>
<p><em>Note:</em> If you want to match a dragging destination which is currently hovered by a dragged element you just need to append the hover flag: the drop target will be matched when any part of the combined boundary of the dragged element and the contact area of the input device touches it.</p>
<pre><span class="comment">//matches every dragging destination elements when a dragged
//element is over it</span>
<span class="flag">::target::hover</span> { }</pre>
<p>The <strong>focus flag</strong> matches the element that currently receives user input (through tabbing for example).</p>
<pre><span class="comment">//matches every element which receives user input</span>
<span class="flag">::focus</span> { }</pre>
<p>The <strong>select flag</strong> matches characters or elements that are currently selected. It ceases if a click or a tap occurs afterward.</p>
<pre><span class="comment">//matches elements which are currently selected</span>
<span class="flag">::select</span> { }
<span class="comment">//matches all characters that are currently selected</span>
* <span class="combinator">&gt;</span> <span class="flag">::select</span> { }</pre>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.4" id="n1.5.4">1.5.4</a></span> The attribute filter</h4>
<p>You can filter elements based on their attributes using the <strong>attribute filter</strong>.</p>
<pre>
<span class="comment">//matches elements which have a title attribute</span>
:[title] { }
<span class="comment">//matches elements which have a title AND an href attribute</span>
:[title]:[href] { }
<span class="comment">//matches elements which have a title OR an href attribute</span>
:[title, href] { }
<span class="comment">//which is equivalent to</span>
:[title], :[href] { }</pre>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.5" id="n1.5.5">1.5.5</a></span> Text matching filters</h4>
<p>These filters select elements which text&#8212;either the content text or the value of the attribute(s)&#8212;matches a given string, condition or pattern. You can use the sensitive argument to enable the case sensitivity.</p>
<p>The <strong>contains filter</strong> matches elements that contain a given string in their texts.</p>
<pre><span class="comment">//matches every element whose content text contains "reminder"
//regardless of the case</span>
<span class="filter">:contains</span>(<span class="string">"reminder"</span>) { }
<span class="comment">//matches every element whose content text exactly contains "Reminder"</span>
<span class="filter">:contains</span>(<span class="string">"Reminder"</span>, sensitive) { }
<span class="comment">//matches every element whose title attribute contains "reminder"</span>
:[title<span class="filter">:contains</span>(<span class="string">"reminder"</span>)] { }</pre>
<p>The <strong>equals filter</strong> matches any element whose text is a given string.</p>
<pre><span class="comment">//matches every element whose content text is equal to "reminder"</span>
<span class="filter">:equals</span>(<span class="string">"reminder"</span>) { }</pre>
<p>The <strong>startsWith filter</strong> matches elements whose texts start with a given string.</p>
<pre><span class="comment">//matches every element whose content text starts with "reminder"</span>
<span class="filter">:startsWith</span>(<span class="string">"reminder"</span>) { }</pre>
<p>The <strong>endsWith filter</strong> matches elements whose texts end with a given string.</p>
<pre><span class="comment">//matches every element whose content text ends with "reminder"</span>
<span class="filter">:endsWith</span>(<span class="string">"reminder"</span>) { }</pre>
<p>The <strong>match filter</strong> matches elements whose texts match a given regular expression.</p>
<pre><span class="comment">//matches every element whose content text starts with a number</span>
<span class="filter">:match</span>(<span class="string">/^[0-9]/</span>) { }</pre>
<p>The <strong>empty filter</strong> matches elements which have no text <em>nor</em> children or whose attributes' values are empty.</p>
<pre><span class="comment">//matches elements which have at least one attribute set to ""</span>
:[*<span class="filter">:empty</span>] { }</pre>
<p>The <strong>length filter</strong> use a criterion to match elements or compares the length of the text against a given condition.</p>
<pre><span class="comment">//matches every element whose content text's length is greater
//than 3 characters</span>
<span class="filter">:length</span>(&gt; <span class="number">3</span>) { }
<span class="comment">//matches the element(s) whose content text has the most characters</span>
<span class="filter">:length</span>(max) { }
<span class="comment">//matches the element(s) whose content text has the less characters</span>
<span class="filter">:length</span>(min) { }</pre>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.6" id="n1.5.6">1.5.6</a></span> Property filters</h4>
<p>Conditions are used to test whether an element is matched based on its properties. The computed values are tested against, not the declared ones. For example if you set the height of a container to 50%, the value will be dynamically returned in points. The properties are on the left side of the comparator, the values on the right.</p>
<pre><span class="comment">//matches all elements whose content text is <em>select me</em></span>
<span class="selector">*</span>:(<span class="property">content</span> = "select me") { }
<span class="comment">//matches all elements with a background</span>
<span class="selector">*</span>:(<span class="property">background</span>) { }
<span class="comment">//which is equivalent to</span>
<span class="selector">*</span>:(<span class="property">background</span> != no) { }
<span class="comment">//similarly, this matches invisible elements</span>
<span class="selector">*</span>:(<span class="modifier">!</span><span class="property">visible</span>) { }
<span class="comment">//which is equivalent to</span>
<span class="selector">*</span>:(<span class="property">visible</span> = no) { }
<span class="comment">//matches all elements which are using a font object named <em>serif</em></span>
<span class="selector">*</span>:(<span class="property">font</span> = serif) { }
<span class="comment">//matches all elements that are taller than 300 and not wider than 400</span>
<span class="selector">*</span>:(<span class="property">height</span> &gt; <span class="number">300</span> &amp; <span class="property">width</span> &lt; <span class="number">400</span>) { }
<span class="comment">//matches any element which surface is square shaped</span>
<span class="selector">*</span>:(<span class="property">height</span> = ref(<span class="property">width</span>)) { }
<span class="comment">//matches any element which height's value returns a number</span>
<span class="selector">*</span>:(<span class="property">height</span>.<span class="property">type</span> = <span class="string">"number"</span>) { }</pre>
<p><em>Note:</em> If recursion occurences are detected the condition(s) will be evaluated in one pass thus the value(s) returned will always be the same.</p>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.7" id="n1.5.7">1.5.7</a></span> Splitters</h4>
	<p>Splitters are preceded by <code>/</code> and directly act on the current selection outputting one or more collections in result. The sorting of the returned collections is determined by the elements' order in the source.</p>
	<p>The <a id="s_each"><strong>each splitter</strong></a> separates each element that would otherwise be joined in a selection. Apart from being a content text splitter, it is particularly useful in association with sibling combinators, <a href="#n1.5.8">collection filters</a> or other splitters.</p>
	<p>Using the <a id="s_type"><strong>type splitter</strong></a> you can rearrange the elements of a collection by types. Put simply the type of an element is its tag's name.</p>
<pre><span class="selector">notes</span>
{
	<span class="comment">//this will match the children of each <em>note</em> elements which
	//are the second of their type; in our example it would select
	//the second <em>message</em> element from the first <em>note</em></span>
	<span class="selector">note</span><span class="splitter">/each</span> <span class="splitter">/type</span><span class="filter">:nth(<span class="number">2</span>)</span> { }
}</pre>
	<p>The <a id="s_attr"><strong>attribute splitter</strong></a> allows the splitting of elements into separate collections in relation to either an attribute's name or an attribute's value.</p>
<pre class="xml">&lt;matches&gt;
   &lt;match0 louis="won" schmeling="lost" name="Fight of the Century" /&gt;
   &lt;match1 ali="lost" frazier="won" name="Fight of the Century" /&gt;
   &lt;match2 ali="won" frazier="lost" /&gt;
   &lt;match3 ali="won" frazier="lost" name="Thrilla in Manila" /&gt;
&lt;/matches&gt;</pre>
<pre><span class="comment">//the splitter returns 3 collections in this order: louis, frazier and ali
//this selects the first element of each boxer collection:
//<em>match0</em> (for Louis), <em>match1</em> (for Frazier) and <em>match2</em> (for Ali)</span>
<span class="selector">matches</span> <span class="splitter">/attr(<span class="string">"won"</span>)</span><span class="filter">:first</span> { }

<span class="comment">//this returns 2 collections: "Fight of the Century" and "Thrilla in Manila"
//the first one contains 2 elements and the second only 1
//here we are selecting the first element of each collection: <em>match0</em> and <em>match3</em></span>
<span class="selector">matches</span> <span class="splitter">/attr(name)</span><span class="filter">:first</span> { }</pre>
	<p><em>Note:</em> You can't negate a splitter.</p>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.8" id="n1.5.8">1.5.8</a></span> Collection Filters</h4>
	<p>The <strong>amount filter</strong> matches elements depending on their current number in the returned collection(s). If a number or a condition is given, the amount of elements is compared.</p>
<pre><span class="comment">//this matches if the sibling collection has exactly 3 elements</span>
<span class="filter">:amount</span>(<span class="number">3</span>) { }
<span class="comment">//this matches if the collection contains 4 or more elements</span>
<span class="filter">:amount</span>(&gt;= <span class="number">4</span>) { }
<span class="comment">//this matches the type collections which exactly return 4 elements</span>
<span class="splitter">/type</span><span class="filter">:amount</span>(<span class="number">4</span>) { }</pre>
	<p>The <strong>is filter</strong> lets you filter the returned collection(s) by a particular element type.</p>
<pre><span class="selector">notes</span>
{
	<span class="comment">//this will only match the <strong>first siblings</strong> following <em>from</em> elements
	//under each <em>note</em> elements <strong>provided that</strong> these siblings are <em>message</em> elements</span>
	<span class="selector">note</span><span class="splitter">/each</span> <span class="selector">from</span> <span class="combinator">+</span> <span class="filter">:first</span><span class="filter">:is(<span class="selector">message</span>)</span> { }
	<span class="comment">//this matches, inside each <em>note</em> elements separately,
	//the first <em>message</em> elements following a <em>from</em> element
	//these elements could be positioned <u>anywhere</u> in their siblings' collections</span>
	<span class="selector">note</span><span class="splitter">/each</span> <span class="selector">from</span> <span class="combinator">+</span> <span class="selector">message</span><span class="filter">:first</span> { }

	<span class="comment">//this matches the fourth element out of the combined collection
	//of notes' children if it's not a <em>message</em> element</span>
	<span class="selector">note</span> <span class="filter">:nth(<span class="number">4</span>)</span><span class="modifier">!</span><span class="filter">:is(<span class="selector">message</span>)</span> { }
	<span class="comment">//if the <em>message</em> element is either the 1st, 2nd, 3rd or 4th element
	//and then removed from the returned collection (!message)
	//it would have an impact on the position of the remaining elements
	//in these cases the following example wouldn't match the
	//same element(s) than the previous example</span>
	<span class="selector">note</span> <span class="modifier">!</span><span class="selector">message</span><span class="filter">:nth(<span class="number">4</span>)</span> { }
}</pre>
	<p>Using the <strong>oneIs filter</strong> you can match a collection on the condition that it contains a certain element.</p>
<pre><span class="selector">notes</span>
{
	<span class="comment">//this matches the children of the first <em>note</em> element
	//if one of them is a <em>from</em> element</span>
	<span class="selector">note</span><span class="filter">:first</span> <span class="filter">:oneIs(<span class="selector">from</span>)</span> { }
}</pre>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.9" id="n1.5.9">1.5.9</a></span> Custom macros</h4>
<p>In HSS it is possible to create your own set of macros using the <code>#macro</code> instruction. They can also be imported from an external file, as any other part of your HSS code, which enables the creation of custom libraries.</p>
<pre>
<span class="comment">//used to style the first element out of the ones which have a black background</span>
<span class="instruction">#macro</span> firstBlack { :(background = black):first }
<span class="comment">//this creates an alias for :startsWith()</span>
<span class="instruction">#macro</span> sw(myArg) { :startsWith(myArg) }
<span class="comment">//creates a macro which selects the first or the last element</span>
<span class="instruction">#macro</span> limit { :first, :last }
<span class="comment">//macros are reusable inside other macros' definitions</span>
<span class="instruction">#macro</span> wideLimit { :(width > ref(height)):::limit }
<span class="comment">//flags are accepted as well</span>
<span class="instruction">#macro</span> dock { ::target::hover }

:::firstBlack { }
:::sw() { }
:::limit { }
:::wideLimit { }
:::dock { }
</pre>
</div>
<div class="sub part">
<h4 class="title"><span class="number"><a href="#n1.5.10" id="n1.5.10">1.5.10</a></span> User flags</h4>
#TODO <a href="https://github.com/AXR/Specification/issues/36">Issue 36</a>
</div>
<div class="sub yet">
<h4 class="title"><span class="number"><a href="#n1.5.11" id="n1.5.11">1.5.11</a></span> Object filter</h4>
<p>In HSS, elements are container objects. Furthermore, there are objects <a href="#n1.7.5">descending</a> from <a href="http://hss.axr.vg/@container">@container</a> which have additional properties: without the object filter you couldn't target them specifically.</p>
<pre><span class="comment">//this matches @container objects indiscriminately</span>
<span class="selector">element</span> { }
<span class="comment">//this matches image elements</span>
<span class="selector">element</span><span class="filter">:@image</span> { }
<span class="comment">//this matches video elements</span>
<span class="selector">element</span><span class="filter">:@video</span> { }</pre>
</div>
</section>
<section class="chapter">
	<h3 class="title"><span class="number"><a href="#n1.6" id="n1.6">1.6</a></span> Properties</h3>

	<div class="sub part">
	<h4 class="title"><span class="number"><a href="#n1.6.1" id="n1.6.1">1.6.1</a></span> Literal values</h4>
	<p>Literal values are keywords, numbers and strings.</p>
	<h5>Special keywords</h5>
	<p>Special keywords are considered valid values for all HSS properties.</p>
	<p>The <strong>default</strong> value of a property is used to (re)set a value to its default value.</p>
<pre><span class="selector">element</span>
{
    <span class="property">height</span>: 50;
    <span class="property">width</span>:  100;
    @<span class="flag">::hover</span>
    {
        <span class="comment">//using <a href="#n1.6.5">grouping</a> this resets the height and width
        //to their default values (respectively <em>content</em> and <em>100%</em>)</span>
        <span class="property">height</span>, <span class="property">width</span>: default;
    }
}</pre>
	<p>The <strong>inherit</strong> value of a given property will correspond to the current value of the element's parent matching property. If the value returned is <em>inherit</em> it will use the property of the parent's own parent, and so on, until it picks up a non-inherit value.</p>
<pre><span class="selector">parent</span>
{
    <span class="property">width</span>: content;
    <span class="comment">//the child inherits the <em>content</em> value (<strong>not its computed value</strong>)</span>
    <span class="selector">child</span> { <span class="property">width</span>: inherit }
}</pre>
	<p><em>Note:</em> The inherit value is not allowed on properties set on the root element. You can't separately inherit one value from multi-value properties because their values don't have a fixed order. To retrieve the computed value of a property you can use a <a href="#n1.6.3.1">reference</a>.</p>
	<p>Using the <strong>current</strong> value you can retrieve the current value(s) of a property whether it has been explicitly set earlier or not. If a property has multiple values set it will refer them as a whole.</p>
<pre><span class="comment">//assuming the background property has currently "object1, object2" as values</span>
<span class="property">background</span>: current, object3;
<span class="comment">//would be equivalent to</span>
<span class="property">background</span>: object1, object2, object3;</pre>
	</div>
	<div class="sub comp">
	<h4 class="title"><span class="number"><a href="#n1.6.2" id="n1.6.2">1.6.2</a></span> Expressions</h4>
	<p>You can write an expression anywhere a numerical value is accepted, and it is generally only useful when used with a variable value. If all the values are fixed numbers, the result will be calculated at parse time and it would be interpreted as if the result had been written. The available operations are: sum (+), subtraction (&#8722;), multiplication (&#215;) and division (&#8725;). You can also use parentheses to designate the order of the operations, in an inside-out order. Otherwise, multiple operations are executed following the mathematical order (first multiply and divide, then sum and subtract).</p>
<pre><span class="comment">//this element will always be twice as wide as its current height</span>
<span class="selector">element</span> { <span class="property">width</span>: 2 * ref(<span class="property">height</span>); }

<span class="comment">//using the <a href="http://hss.axr.vg/@these#count">count property</a>, this permits to perfectly fit
//the <em>child</em> element(s) in their parent to prevent wrapping</span>
<span class="selector">parent child</span> { <span class="property">width</span>: 100% / @these.count); }</pre>
	</div>
	<div class="sub part">
	<h4 class="title"><span class="number"><a href="#n1.6.3" id="n1.6.3">1.6.3</a></span> Functions</h4>
	<p>Functions take some parameters and create an output. The result of the function is what is assigned to the property.</p>
	<h4 class="subsec"><a id="n1.6.3.a">Retrieval functions</a></h4>
	<h5><a href="#n1.6.3.1" id="n1.6.3.1">References</a></h5>
	<p>You can take values from other elements to apply them to the properties of the currently selected element(s).&#160; The value returned is always the computed value of that property, not the declared one. The syntax is <span>ref(<span class="property">propertyName</span> of <span class="selector">selector</span>)</span> and can be used anywhere a value is accepted.</p>
	<p>Consider the following XML snippet:</p>
<pre class="xml">&lt;<span class="selector">parent</span>&gt;
    &lt;<span class="selector">child1</span>&gt;dynamically generated content text, changes in height&lt;/<span class="selector">child1</span>&gt;
    &lt;<span class="selector">child2</span>&gt;static content text&lt;/<span class="selector">child2</span>&gt;
&lt;/<span class="selector">parent</span>&gt;</pre>
	<p>Suppose that in your layout each child elements is a column, taking half of the horizontal width. If you wanted the second child element to always have the same height as the first one, since the first changes in height, you could not use any static value. Instead, you would reference the first child from the second one.</p>
<pre><span class="selector">parent child2</span>
{
    <span class="comment">//this gives both columns the same height</span>
    <span class="property">height</span>: ref(<span class="property">height</span> of <span class="selector">child1</span>);
    <span class="comment">//since the property referenced is the same
    //as the one we are setting, this is equivalent</span>
    <span class="property">height</span>: ref(of <span class="selector">child1</span>);
    <span class="comment">//using the <a href="#n1.6.3.8">min function</a>, you can prevent
    //the child2's height from dropping below its content's height</span>
    <span class="property">height</span>: min(content, ref(of <span class="selector">child1</span>));
}</pre>
	<p>As you can see, the scope of the specified selector is the scope of the element on which you are declaring the reference. To select elements outside of that scope, the <span class="object">@parent</span> or <span class="object">@root</span> objects are used.</p>
	<p>In case you are referencing another property of the element(s) on which you are declaring the reference, a shorthand exists:</p>
<pre><span class="selector">parent</span>
{
    <span class="property">height</span>: ref(<span class="property">width</span> of <span class="selector">@this</span>);
    <span class="comment">//which is equivalent to</span>
    <span class="property">height</span>: ref(<span class="property">width</span>);
}</pre>
	<p>Using the sum, avg, max and min <strong>modifiers</strong> you can respectively do a summation, get an average and retrieve the maximum or minimum.</p>
<pre><span class="selector">parent *</span>
{
    <span class="comment">//this sets the width of the children of each parent element
    //to the width of whichever is currently the widest child</span>
    <span class="property">width</span>: ref(<span class="modifier">max</span> <span class="property">width</span> of <span class="selector">*</span>);
    <span class="comment">//which is equivalent to</span>
    <span class="property">width</span>: ref(<span class="modifier">max</span> <span class="property">width</span> of <span class="selector">@these</span>);
}</pre>
	<p>Normally if several elements, which don't share the same value for the referenced property, are matched by the inner selector, the reference, expecting only one value, will return nothing. Setting modifiers or using certain <a href="#n1.3.7">reference objects</a> as the selector permit to bypass this rule.</p>
<pre><span class="selector">parent</span>
{
    <span class="selector">child1</span> { <span class="property">background</span>: #0 }
    <span class="selector">child2</span> { <span class="property">background</span>: #F }
    <span class="selector">child3</span> { <span class="property">background</span>: #0 }

    <span class="comment">//this reference won't return anything</span>
    <span class="property">background</span>: ref(<span class="property">background</span> of <span class="selector">@this *</span>);
    <span class="comment">//this one returns #0</span>
    <span class="property">background</span>: ref(<span class="property">background</span> of <span class="selector">@this *<span class="filter">:odd</span></span>);
}</pre>
	<h5><a href="#n1.6.3.2" id="n1.6.3.2">The attribute function</a></h5>
	<p>The syntax is <code>attr(attributeName of <span class="selector">selector</span>)</code> and can be used anywhere a string is accepted. Analogous to references, the function won't return anything if the elements matched don't share the same attribute's value.</p>
<pre><span class="selector">element</span>
{
    <span class="comment">//this would replace the content text of the element
    //by the value of its href attribute</span>
    <span class="property">content</span>: attr(href of <span class="selector">@this</span>);
    <span class="comment">//which is equivalent to</span>
    <span class="property">content</span>: attr(href);
}</pre>
	<h5><a href="#n1.6.3.3" id="n1.6.3.3">The selector function</a></h5>
	<p>The syntax is <code>sel(<span class="selector">selector</span>)</code> and can be used anywhere elements are accepted.</p>
	<h4 class="subsec"><a id="n1.6.3.b">Type conversion functions</a></h4>
	<h5><a href="#n1.6.3.4" id="n1.6.3.4">The object function</a></h5>
	<p>It can be used anywhere objects are accepted. It permits to enforce the type of the value when a property accept keywords <strong>and</strong> object names: in the event of a name clash the keyword takes precedence normally. It can also be used to convert a string to an object name (granted that the outputted name is valid).</p>
<pre><span class="selector">element</span>
{
    <span class="comment">//sets the background to black using a keyword</span>
    <span class="property">background</span>: black;
    <span class="comment">//sets the background to an object named <em>black</em> (assuming it has been defined)</span>
    <span class="property">background</span>: obj(black);
    <span class="comment">//since background doesn't have a <em>bg</em> keyword
    //this sets the background to an object named <em>bg</em> (assuming it has been defined)</span>
    <span class="property">background</span>: bg;
    <span class="comment">//which is equivalent to</span>
    <span class="property">background</span>: obj(bg);
}</pre>
	<h5><a href="#n1.6.3.5" id="n1.6.3.5">The keyword function</a></h5>
	<p>It can be used anywhere keywords are accepted. It is mainly used to convert <span class="compound-word">single-word</span> strings to keywords. It also filters what's passed to it by discarding numbers, objects and <span class="compound-word">multi-word</span> strings.</p>
<pre><span class="selector">element</span>
{
    <span class="comment">//assuming we have a <em>visible</em> attribute set on the element
    //its value would be converted to a keyword
    //it doesn't ensure it will be valid on this property</span>
    <span class="property">visible</span>: kwd(attr(visible));
}</pre>
	<h5><a href="#n1.6.3.6" id="n1.6.3.6">The string function</a></h5>
	<p><code>str()</code> can be used anywhere strings are accepted. It stringifies what's passed to it.</p>
	<h5><a href="#n1.6.3.7" id="n1.6.3.7">The number function</a></h5>
	<p><code>num()</code> can be used anywhere numbers are accepted. It converts strings into numbers (provided that they contain precisely one number). It also filters what's passed to it by discarding keywords and objects.</p>
	<h4 class="subsec"><a id="n1.6.3.c">Arithmetic functions</a></h4>
	<h5><a href="#n1.6.3.8" id="n1.6.3.8">The bounding functions</a></h5>
	<p>Using the bounding functions you can constrain numeric values to certain limits.</p>
<pre><span class="selector">element</span>
{
    <span class="comment">//if 20% of the parent's innerWidth represents less than 100
    //this sets the width to 100 and 20% otherwise</span>
    <span class="property">width</span>: min(100, 20%);
    <span class="comment">//similarly, if 50% of the parent's innerWidth represents 300 or more
    //this sets the width to 300 and defaults to 50% in other cases</span>
    <span class="property">width</span>: max(300, 50%);
    <span class="comment">//this sets the width to 300 until the maximum threshold is reached
    //at which point it locks itself at 50% of the parent's innerWidth</span>
    <span class="property">width</span>: max(50%, 300);
    <span class="comment">//this sets a lower and an upper limit of respectively
    //200 for the minimum and 400 for the maximum</span>
    <span class="property">width</span>: bound(200, 30%, 400);
    <span class="comment">//which is equivalent to</span>
    <span class="property">width</span>: min(200, max(400, 30%));
}</pre>
	<p>The bound function has two valid syntaxes:</p>
	<ul>
		<li><code>bound(variable, static, variable)</code></li>
		<li><code>bound(static, variable, static)</code></li>
	</ul>
	<p>The max and min functions share the same syntaxes:</p>
	<ul>
		<li><code>min(static, variable)</code> and <code>max(static, variable)</code></li>
		<li><code>min(variable, static)</code> and <code>max(variable, static)</code></li>
	</ul>
	<p><em>Note:</em> the third argument of the bound function must always be greater than the first one.</p>
	<h5><a href="#n1.6.3.9" id="n1.6.3.9">The rounding functions</a></h5>
<pre><span class="comment">//346</span>
round(<span class="number">346.238</span>)
<span class="comment">//346.24</span>
round(<span class="number">346.238</span>, 2)
<span class="comment">//300</span>
round(<span class="number">346.238</span>, -2)
<span class="comment">//347</span>
round(<span class="number">346.238</span>, odd)
<span class="comment">//which is equivalent to</span>
round(<span class="number">346.238</span>, 0, odd)
<span class="comment">//346</span>
round(<span class="number">346.238</span>, even)
<span class="comment">//which is equivalent to</span>
round(<span class="number">346.238</span>, 0, even)
<span class="comment">//-346 (default half up)</span>
round(<span class="number">-346.5</span>)
<span class="comment">//-347</span>
round(<span class="number">-346.5</span>, down)
<span class="comment">//which is equivalent to</span>
round(<span class="number">-346.5</span>, 0, down)</pre>

<pre><span class="comment">//347</span>
ceil(<span class="number">346.238</span>)
<span class="comment">//-346</span>
ceil(<span class="number">-346.238</span>)
<span class="comment">//346.24</span>
ceil(<span class="number">346.238</span>, 2)
<span class="comment">//400</span>
ceil(<span class="number">346.238</span>, -2)</pre>

<pre><span class="comment">//346</span>
floor(<span class="number">346.238</span>)
<span class="comment">//-347</span>
floor(<span class="number">-346.238</span>)
<span class="comment">//346.23</span>
floor(<span class="number">346.238</span>, 2)
<span class="comment">//300</span>
floor(<span class="number">346.238</span>, -2)</pre>
	</div>
	<div class="sub part">
	<h4 class="title"><span class="number"><a href="#n1.6.4" id="n1.6.4">1.6.4</a></span> Color</h4>
	<p>For convenience and compatibility with common graphic edition programs, color values in the sRGB color space can be written as <strong>instructions</strong>. It is composed of a hash (number sign) <code>#</code> followed by a number in hexadecimal notation of one to eight digits. If omitted the alpha channel defaults to <code>FF</code>.</p>
<pre>
<span class="comment">//this would set the background to white</span>
<span class="property">background</span>: #FFFFFF;
	    <span class="comment">//which can be alternatively be written</span>
     &#12291;	    #FFF;
	    <span class="comment">//or</span>
     &#12291;	    #FF;
	    <span class="comment">//or</span>
     &#12291;	    #F;

<span class="comment">//sets the alpha channel to CC using the #RRGGBBAA format</span>
<span class="property">background</span>: #552211CC;
	    <span class="comment">//which can be alternatively be written</span>
     &#12291;	    #552211C;
	    <span class="comment">//or</span>
     &#12291;	    #521CC;
	    <span class="comment">//or</span>
     &#12291;	    #521C;
</pre>
	<p>Besides instructions, you can also use <strong>objects</strong> (<a href="http://hss.axr.vg/@rgb">@rgb</a>, <a href="http://hss.axr.vg/@cmyk">@cmyk</a> and <a href="http://hss.axr.vg/@hsb">@hsb</a>) and <strong>keywords</strong> (black, white and transparent) as color values.</p>
	</div>
	<div class="sub yet">
	<h4 class="title"><span class="number"><a href="#n1.6.5" id="n1.6.5">1.6.5</a></span> Property grouping</h4>
	<p>You can group two or more properties which share the same value(s).</p>
<pre><span class="selector">element</span>
{
    <span class="property">width</span>, <span class="property">height</span>: 100%;
    <span class="comment">//which is equivalent to</span>
    <span class="property">width</span>: 100%;
    <span class="property">height</span>: 100%;
}</pre>
	</div>
	<div class="sub yet">
	<h4 class="title"><span class="number"><a href="#n1.6.6" id="n1.6.6">1.6.6</a></span> The value selector</h4>
	<p>Certain properties accept multiple values, in these cases the value selector <code>[]</code> permits to select them by name or using a filter.</p>
<pre><span class="selector">element</span> {
    <span class="comment">//supposing these container objects were defined elsewhere</span>
    <span class="property">isA</span>: objectA, objectX, objectY;
    <span class="comment">//this would set objectY's width to 50</span>
    <span class="property">isA</span>[objectY].<span class="property">width</span>: <span class="number">50</span>;
    <span class="comment">//which is equivalent to</span>
    <span class="property">isA</span>[<span class="filter">:last</span>].<span class="property">width</span>: <span class="number">50</span>;
    <span class="comment">//and naturally, <a href="#n1.3.3">selector grouping</a> remains available</span>
    <span class="property">isA</span>[:first, objectX].<span class="property">width</span>: <span class="number">80</span>;
}</pre>
	</div>
	<div class="sub yet">
	<h4 class="title"><span class="number"><a href="#n1.6.7" id="n1.6.7">1.6.7</a></span> Boolean casting</h4>
	<p>Using the <a href="#n1.2.6">negator</a> you can convert a value to a boolean.</p>
<pre><span class="comment">//this sets the property to <em>no</em> for any value
//except !no which returns <em>yes</em></span>
<span class="property">property</span>: <span class="modifier">!</span>value;
<span class="comment">//this sets the property to <em>yes</em> for any value
//except !!no which returns <em>no</em></span>
<span class="property">property</span>: <span class="modifier">!!</span>value;</pre>
	</div>
</section>
<section class="chapter">
	<h3 class="title"><span class="number"><a href="#n1.7" id="n1.7">1.7</a></span> Objects</h3>
	<p>Objects have a hierarchy, in which objects can descend from others, hence inheriting all the properties defined in their <a href="#n1.3.7.6">owner</a>. This enables great flexibility and modularization of the code.</p>
	<p>Objects can be set to be of a certain type, placing an object type immediately after the at sign, or automatically deriving it from the context. It is followed by whitespace, and optionally an object name and more optional whitespace, followed by a block. Inside the block, its properties are defined.</p>
	<div class="sub yet">
	<h4 class="title"><span class="number"><a href="#n1.7.1" id="n1.7.1">1.7.1</a></span> Object dot notation</h4>
	</div>
	<div class="sub comp">
	<h4 class="title"><span class="number"><a href="#n1.7.2" id="n1.7.2">1.7.2</a></span> Named objects</h4>
	</div>
	<div class="sub comp">
	<h4 class="title"><span class="number"><a href="#n1.7.3" id="n1.7.3">1.7.3</a></span> Anonymous objects</h4>
	</div>
	<div class="sub comp">
	<h4 class="title"><span class="number"><a href="#n1.7.4" id="n1.7.4">1.7.4</a></span> Shorthand notation</h4>
	</div>
	<div class="sub comp">
	<h4 class="title"><span class="number"><a href="#n1.7.5" id="n1.7.5">1.7.5</a></span> Grouping and inheritance</h4>
	</div>
</section>
<section class="chapter">
	<h3 class="title"><span class="number"><a href="#n1.8" id="n1.8">1.8</a></span> Instructions</h3>
</section>
</div>
<div id="btt"><a href="#toc">table of contents</a></div>
</body>
</html>
