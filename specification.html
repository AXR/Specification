<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">

<!--***************************************************************
 
      AUTHORS: Miro Keller and collaborators
      
      COPYRIGHT: ©2011 - All Rights Reserved

      LICENSE: see License.txt file

      WEB: http://axr.vg

      THIS CODE AND INFORMATION ARE PROVIDED "AS IS"
      WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR
      FITNESS FOR A PARTICULAR PURPOSE.

*******************************************************************

      FILE INFORMATION:
      =================
      Last changed: 2012/05/21
      HSS version: 1.0
      Revision: 1.1m2

****************************************************************-->

	<title>The AXR Specification</title>
	<meta name="author" content="Miro Keller, Marc G.">
	<style>
	
	body
	{
		width: 720px;
		font-family: "Century Gothic", "Futura", "Verdana", sans-serif;
		margin: 30px auto;
		color: #666;
	}
	
	a[href^="#"], :local-link
        {
                -moz-text-decoration-line:underline;
                -moz-text-underline-style:dotted;
        }
        
	.notice
	{
		margin: 20px auto;
		background-color: rgba(153,153,153,0.1);
		padding: 20px;
		border-radius: 15px
	}

	.notice p
	{
		margin: 5px 0;
	}

	.notice strong
	{
		color: red;
	}

	p.center, h1
	{
		text-align: center;
	}

	p > span
	{
		background: #fef3c8;
		padding: 0 2px;
		border: 1px solid #dca992;
		color: #b5471a;
		border-radius: 2px;
		font-family: monospace;
	}
	
	code, pre
	{
		background: #FEF3C8;
		padding: 20px;
		border: 1px solid #DCA992;
		color: #B5471A;
		border-radius: 2px;
		white-space: pre-wrap;       /* css-3 */
		white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
		white-space: -pre-wrap;      /* Opera 4-6 */
		white-space: -o-pre-wrap;    /* Opera 7 */
		word-wrap: break-word;
	}
	
	p code
	{
		padding: 0 2px;
	}

	.comment
	{
		color: #95877e;
	}

	.selector
	{
		color: #fd2f7a;
	}

	.property
	{
		color: #1b8a93;
	}

	.filter
	{
		color: #199013;
	}

	.combinator
	{
		color: #1e97f4;
	}

	.object
	{
		color: #933492;
	}

	.number
	{
		color: #2146fa;
	}

	.string
	{
		color: #fd2716;
	}
	
	.value
	{

	}
	
	.modifier
	{

	}
        
        .instruction
	{

	}
	
	.expression
	{

	}
	
	.flag
	{

	}

	pre .highlighted
	{
		background-color: #fefefe;
	}

	table
	{
		width: 100%;
		border: 1px solid #CCC;
	}

	table th
	{
		background-color: #CCC;
		padding: 10px;
	}


	table th:first-child
	{

	}

	table td
	{
		border: 1px solid #CCC;
		text-align: left;
		padding: 10px;
	}

	pre.xml
	{
		background-color: #d6fcd0;
		border-color: #5bac80;
		color: #498e68;
	}

	ul, #spec ol
	{
		list-style: inside;
		line-height: 1.4;
		margin: 10px;
	}

	ul li, ol li
	{
		color: #666666;
	}
	
	nav li
	{
		list-style:none;
		font-size:small
	}
        
	nav li li
	{
		font-size:smaller
	}
	
	nav > ul
	{
		counter-reset:section;
		background-color:#f5f7f6;
		margin:0 auto;
		padding:20px;
		-moz-column-count: 2;
		-moz-column-gap: 1em;
		-webkit-column-count: 2;
		-webkit-column-gap: 1em;
		column-count: 2;
		column-gap: 1em;
		height: 530px;
	}
	
	nav > ul > li
	{
		counter-reset:subsection;
	}
	
	nav > ul > li:before
	{
		counter-increment:section;
		content:"1." counter(section) " ";
	}
	
	nav ul ul > li:before 
	{
		counter-increment:subsection;
		content:"1." counter(section) "." counter(subsection) " ";
	}
	
	#btt {
		position:fixed;
		bottom:5px;
		right:5px;
		font-size:xx-small;
	}
	</style>
</head>
<body>
<div id="draft_warning" class="notice">
	<p><strong>Warning!</strong></p>
	<p>This file is an editor’s draft and should not be considered final.</p>
</div>

<h1>Arbitrary XML Rendering Specification</h1>
<nav><a name="toc"></a>
<ul>
<li><a href="#1.1">Introduction</a></li>
<li><a href="#1.2">The primary building blocks</a>
	<ul>
	     <li><a href="#1.2.1">Rules</a></li>
	     <li><a href="#1.2.2">Selector basic principles</a></li>
	     <li><a href="#1.2.3">Properties</a></li>
	     <li><a href="#1.2.4">Objects</a></li>
	     <li><a href="#1.2.5">Instructions</a></li>
	     <li><a href="#1.2.6">Negation</a></li>
	</ul>
</li>
<li><a href="#1.3">Selectors</a>
	<ul>
	     <li><a href="#1.3.1">A simple selector</a></li>
	     <li><a href="#1.3.2">Hierarchy &amp; Scope</a></li>
	     <li><a href="#1.3.3">Grouping</a></li>
	     <li><a href="#1.3.4">The universal selector</a></li>
	     <li><a href="#1.3.5">Selecting the subject</a></li>
	     <li><a href="#1.3.6">Regex selector</a></li>
	</ul>
</li>
<li><a href="#1.4">Combinator</a>
	<ul>
	     <li><a href="#1.4.1">Child combinator</a></li>
	     <li><a href="#1.4.2">Descendant combinator</a></li>
	     <li><a href="#1.4.3">Siblings combinator</a></li>
	     <li><a href="#1.4.4">Next and previous siblings combinators</a></li>
	     <li><a href="#1.4.5">Accessing elements laid out in lines</a></li>
	     <li><a href="#1.4.6">Accessing the content text</a></li>
	</ul>
</li>
<li><a href="#1.5">Filters &amp; Flags</a>
	<ul>
	     <li><a href="#1.5.1">Position filters</a></li>
	     <li><a href="#1.5.2">Hierarchy filters</a></li>
	     <li><a href="#1.5.3">System flags</a></li>
	     <li><a href="#1.5.4">The attribute filter</a></li>
	     <li><a href="#1.5.5">Text matching filters</a></li>
	     <li><a href="#1.5.6">Property filters</a></li>
	     <li><a href="#1.5.7">Custom filters</a></li>
	     <li><a href="#1.5.8">User flags</a></li>
	</ul>
</li>
<li><a href="#1.6">Properties</a>
	<ul>
	     <li><a href="#1.6.1">Literal values</a></li>
	     <li><a href="#1.6.2">Expressions</a></li>
	     <li><a href="#1.6.3">Functions</a></li>
	     <li><a href="#1.6.4">Color</a></li>
	     <li><a href="#1.6.5">isA</a></li>
	</ul>
</li>
<li><a href="#1.7">Objects</a>
	<ul>
	     <li><a href="#1.7.1">Hierarchy objects</a></li>
	     <li><a href="#1.7.2">Support object</a></li>
	     <li><a href="#1.7.3">Named objects</a></li>
	     <li><a href="#1.7.4">Anonymous objects</a></li>
	</ul>
</li>
</ul>
</nav>
<div id="hss_syntax">
	<h2><span>1</span> The syntax of HSS</h2>
<section class="chapter">
		<h3><span><a name="1.1">1.1</a></span> Introduction</h3>
		<p>HSS stands for Hierarchical Style Sheets and it is the language used to instruct the AXR renderer how the various elements in the document should look like, how they are laid out and, to some extent, how they behave. The syntax of this language is inspired in CSS, but extending and altering it in various ways, to achieve powerful new ways of creating a web document. Therefore, HSS is not compatible with existing CSS files.</p>
		<p class="center"><img src="/sites/default/images/spec/hss_logo.jpg" alt="Hierarchical Style Sheets Logo" /></p>
		<p>HSS inherits the simplicity and clarity of CSSʼ syntax, but stops being a static language, bearing more similarity in some areas to other programming languages. The primary premise for this is the realization that a web page isnʼt a simple hyperlinked text document anymore, but an interactive software, which presents itself to the user through an interface and performs some logic, which may or not be displaying a text document. With this in mind, and the environment in which the document will be accessed (a computing device with an arbitrary display size), it is clear that some sort of interface programming language is needed which is able to express relationships and behaviors, and allows advanced interactivity and layout.</p><p>HSS files are plain-text files, and thus can be edited by any text editor on any platform, although some of its features are better put to use through a visual editing tool, since using code in those cases is less intuitive.</p>
</section>
	
<section class="chapter">
		<h3><span><a name="1.2">1.2</a></span> The primary building blocks</h3>
		<h4><span><a name="1.2.1">1.2.1</a></span> Rules</h4>
		<p>One of the most basic concepts in HSS is the notion of rules. A rule is the combination of a selector and a block, which starts with an opening curly brace <code>{</code> and ends with a closing one <code>}</code>, and may contain property definitions and/or other rules.</p>			
<pre><span class="selector">selector</span>
{
	<span class="property">property definitions</span> ;
}</pre>

		<h4><span><a name="1.2.2">1.2.2</a></span> Selector basic principles</h4>
		<p><a href="#1.3">Selectors</a> are used to point to a certain element(s) of the document, so that the properties defined inside of the block get applied to them. You define a search pattern and all applicable elements will be searched to see if their properties match the defined conditions. If so, the property definitions are applied.</p>
		<p><a href="#1.3.1">Simple selectors</a> are the element name or <a href="#">universal selector</a>, combined with one or several appended <a href="#1.5">filters or flags</a>. A series of simple selectors joined by <a href="#1.4">combinators</a> is called the selector chain or simply selector.</p>
		<p>In order to access elements' parents or the root element you can use <a href="#1.7.1">hierarchy objects</a>. <a href="#1.3.7">Regular expressions</a> are also available to select elements based on their name.</p>
		<p>Some examples:</p>
<pre><span class="comment">//select elements with name “document”</span>
<span class="selector">document</span> { }
<span class="comment">//select the first element with name “book”</span>
<span class="selector">book</span><span class="filter">:first</span> { }
<span class="comment">//select the elements with name “content” that occur after “title”
//elements, which are descendants of “book” elements, which themselves
//are direct children of “books” elements</span>
<span class="selector">books book</span> <span class="combinator">..</span> <span class="selector">title</span> <span class="combinator">+</span><span class="combinator"></span> <span class="selector">content</span> { }</pre>

		<h4><span><a name="1.2.3">1.2.3</a></span> Properties</h4>
		<p>Each element in the document has a certain amount of <a href="#1.6">properties</a>, which you can define using property definitions. They are contained within the block that follows a selector chain.</p>
		<p>To write a property declaration simply place the name of the property, followed by a colon and optional whitespace, and then followed by a literal value, an expression, a function or an object. More whitespace can come afterwards, as well. If it is not the last property declaration of the block, it must be ended by a semicolon, to denote that it finishes on that place, and that what follows is something else.</p>
		<p>Here are some examples:</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this makes it 150 points wide</span>
    <span class="property">width</span>: <span class="number">150</span>;
    <span class="comment">//this makes the element 10 points less high as its parent</span>
    <span class="property">height</span>: <span class="number">100%</span> - <span class="number">10</span>;
    <span class="comment">//this aligns the element to the center of its parent element</span>
    <span class="property">alignX</span>: <span class="number">50%</span>;
    <span class="property">alignY</span>: <span class="number">50%</span>;
}

<span class="comment">//in this example the semicolon was omitted, since it is the
//last element in the block</span>
<span class="selector">document</span> { <span class="property">alignX</span>: <span class="number">50%</span> }</pre>
#TODO <a href="https://github.com/AXR/Specification/issues/10">Issue 10</a>

		<h4><span><a name="1.2.4">1.2.4</a></span> Objects</h4>
		<p><a href="#">Objects</a> represent values that are more complex in their nature. Similar to rules, objects have properties which accept values, defined inside a block. Objects are identified using the object sign <code>@</code> prefixed to their object type.</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this makes the element have rounded corners</span>
    <span class="property">shape</span>: <span class="object">@roundedRect</span> {
        <span class="property">corners</span>: <span class="number">5</span>;
    };
    <span class="comment">//this adds a simple border, 3 points wide and black in color</span>
    <span class="property">border</span>: <span class="object">@lineBorder</span> {
        <span class="property">size</span>: <span class="number">3</span>;
        <span class="property">color</span>: <span class="number">#000</span>;
    };
}</pre>
		<h4><span><a name="1.2.5">1.2.5</a></span> Instructions</h4>
#TODO <a href="https://github.com/AXR/Specification/issues/27">Issue 27</a>

		<h4><span><a name="1.2.6">1.2.6</a></span> The negator</h4>
		<p>You can negate <a href="#1.3.1">simple selectors</a> by prefixing them with <span class="modifier">!</span>, meaning that all elements in the current scope that don’t match the selector will be selected.</p>
<pre><span class="comment">//this selects the children of note which are not message elements</span>
<span class="selector">note</span><span class="combinator"> </span><span class="modifier">!</span><span class="selector">message</span> { }</pre>
		<p>Likewise you can negate <a href="#1.5">filters and flags</a>.</p>
<pre><span class="comment">//this selects any note element which is not the first one</span>
<span class="selector">note</span><span class="modifier">!</span><span class="filter">:first</span> { }
<span class="comment">//this selects any note element which is not the first one
//and does not have a blue background</span>
<span class="selector">note</span><span class="modifier">!</span><span class="filter">:first</span><span class="modifier">!</span>(<span class="property">background</span> = <span class="value">blue</span>) { }</pre>
		<p>To negate an entire selector (including its filters or flags) you have to use the alternate <span class="modifier">!()</span> notation.</p>
<pre><span class="comment">//this matches all elements except the last note(s)</span>
<span class="modifier">!</span>(<span class="selector">note</span><span class="filter">:last</span>) {}</pre>
		<p>The siblings combinators <a href="#1.4.3">=</a> <a href="#1.4.4">+ -</a> can be negated too.</p>
<pre><span class="comment">//this matches <em>message</em> elements which are children of <em>note</em> but don't have a preceding <em>subject</em> sibling</span>
<span class="selector">note</span> <span class="selector">subject</span> <span class="modifier">!</span><span class="combinator">+</span> <span class="selector">message</span> {}</pre>

</section>
	
<section class="chapter">
		<h3><span><a name="1.3">1.3</a></span> Selectors</h3>
		<p>Consider the following XML snippet:</p>
<pre class="xml">&lt;<span class="selector">note</span>&gt;
	&lt;<span class="selector">to</span>&gt;Peter&lt;/<span class="selector">to</span>&gt;
	&lt;<span class="selector">from</span>&gt;James&lt;/<span class="selector">from</span>&gt;
	&lt;<span class="selector">subject</span>&gt;Reminder&lt;/<span class="selector">subject</span>&gt;
	&lt;<span class="selector">message</span>&gt;Please don’t forget to bring some &lt;<span class="selector">important</span>&gt;wine&lt;/<span class="selector">important</span>&gt;&#8230;&lt;/<span class="selector">message</span>&gt;
&lt;/<span class="selector">note</span>&gt;</pre>

		<p>In the following examples we will be using rules, but without property definitions for clarity.</p>
		<h4><span><a name="1.3.1">1.3.1</a></span> A simple selector</h4>
		<p>You can target an element by its name. </p>
<pre><span class="comment">//match every note element (within the current scope) and apply
//the style rules declared within the block (in this case none)</span>
<span class="selector">note</span> { }</pre>

		<h4><span><a name="1.3.2">1.3.2</a></span> Hierarchy &amp; Scope</h4>
		<p>Usually what the HSS author does is following the document tree and applying styles to most elements. Rules can be nested inside other rules which will only match children of the elements matched by the parent selector. This is what gives HSS its name.</p>
		<p>The scope refers to the elements targeted by the selector. In the following example, only subject elements that are children of note can be selected, because the scope is restricted to the children of the note element(s).</p>
<pre><span class="comment">//match every note element (in the current scope)</span>
<span class="selector">note</span><br />{
    <span class="comment">//match every subject element which is a child of the
    //previously selected note element(s)</span>
    <span class="selector">subject</span> { }
}</pre>
#TODO <a href="https://github.com/AXR/Specification/issues/18">Issue 18</a>
<p>Similarly you can nest filters using the <a href="#1.7.1.3">@this</a> object (or its shorthand <span class="object">@</span>).</p>
<pre><span class="selector">note</span><br />{
    <span class="object">@this</span><span class="filter">::hover</span> { }
}

<span class="comment">//which is equivalent to</span>

<span class="selector">note</span><br />{
    <span class="object">@</span><span class="filter">::hover</span> { }
}</pre>
		<h4><span><a name="1.3.3">1.3.3</a></span> Grouping</h4>
		<p>You can group multiple selectors together which is convenient when they share the same properties (or rules).</p>
<pre><span class="comment">//match every subject element and every message element</span>
<span class="selector">subject</span>, <span class="selector">message</span> { }</pre>
                <p>In nested notation, grouping helps getting rid of unnecessary repetition.</p>
<pre>
note {
        child1, child2 {
                        element1, element2 { }
        }
}  
<span class="comment">//which is equivalent to</span>
note { }
note child1, note child2 { }
note child1 element1, note child1 element2,
note child2 element1, note child2 element2 { }
</pre>
		<h4><span><a name="1.3.4">1.3.4</a></span> The universal selector</h4>
		<p>The universal selector <span class="selector">*</span> matches every element in the current scope:</p>
<pre><span class="comment">//matches every element that is a child of &lsquo;note&rsquo;</span>
<span class="selector">note</span>
{
&#160;&#160;&#160; <span class="selector">*</span> { }
}</pre>
<p><em>Note:</em> Since the initial scope is restricted to the root element, using simply the universal selector in the outermost rule set would only select the note element on the example XML code above, unlike what would happen in CSS. To select all elements that are descendants of another you need to use the <a href="#1.4.2">descendant combinator</a>, furthermore to match all scopes you need to start the selector chain with the descendant combinator.</p>
<pre><span class="comment">//matches only the note element</span>
<span class="selector">*</span> { }
<span class="comment">//matches all elements under the note element</span>
<span class="selector">*</span> <span class="combinator">..</span> <span class="selector">*</span> { }
<span class="comment">//matches all elements</span>
<span class="combinator">..</span> <span class="selector">*</span> { }</pre>
<p>If the universal selector is not the only part of the selector, like when it has a filter, for example, it can be omitted. It may be omitted as well if placed between matching combinators (except the child combinator, the siblings combinator and the descendants combinator).</p>
<pre><span class="comment">//the following statements are equivalent</span>
<span class="selector">*</span><span class="filter">:first</span> { }
<span class="filter">:first</span> { }
<span class="comment">//and so are these</span>
<span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> { }
<span class="selector">*</span> <span class="combinator">&gt;&gt;</span> <span class="selector">*</span> { }</pre>
#TODO <a href="https://github.com/AXR/Specification/issues/31">Issue 31</a>
		
		<h4><span><a name="1.3.5">1.3.5</a></span> Selecting the subject</h4>
		<p>You can match an element which isn't the last one in the selector chain using the subject selector <span class="selector">$</span>.</p>
<pre><span class="comment">//matches a note element when the mouse hovers on an
//important element which is his descendant</span>
<span class="selector">$note</span> <span class="combinator">..</span> <span class="selector">important</span><span class="filter">::hover</span> { }
<span class="comment">//matches all note elements which have at least one comment element as a child</span>
<span class="selector">$note</span><span class="combinator"> </span><span class="selector">comment</span> { }</pre>
		<h4><span><a name="1.3.6">1.3.6</a></span> Regex selector</h4>
		<p>You can use a regular expression to select elements based on their names.</p>
<pre><span class="comment">//matches every element whose name starts with a number (in the current scope)</span>
<span class="selector">/^[0-9]/</span> { }
</pre>
</section>
<section class="chapter">
		<h3 class="title"><span class="number"><a name="1.4">1.4</a></span> Combinators</h3>
		<p>Combinators allow you to select an element based on its relationship to another in the hierarchy. Multiple simple selectors can be chained together, forming the selector chain. Usually this is done when you want to “skip” an element and style one that is inside it instead. It is more convenient to use a combinator than to use hierarchy, in the case of child combinators. In other cases, the combinator is needed because with hierarchy alone the same effect could not be achieved.</p><pre><span class="comment">//matches every subject element which is a child of message,
//which itself is a child of note</span>
<span class="selector">note</span> <span class="selector">message</span> <span class="selector">subject</span> { }</pre><p>Keep in mind that these examples only select elements in the current scope, and therefore will select elements depending on where in the hierarchy you are using them.</p>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.4.1">1.4.1</a></span> Child combinator</h4>
		<p>Children—or more explicitly level one descendants—may be selected using the child combinator (whitespace)&nbsp;<span class="combinator"> </span>.</p>
		<p><em>Note:</em> This is different from CSS, where the whitespace represents the descendant combinator. The reasoning behind this is that authors are inherently lazy, and thus end up using the descendant combinator when they really should be using the child combinator instead, because it’s just much more convenient.</p>
<pre><span class="comment">//matches every subject element which is a child of note</span><br><span class="selector">note subject</span> { }</pre>
</div>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.4.2">1.4.2</a></span> Descendant combinator</h4>
		<p>If you want to select elements which are descendants (could be child of a child of the element, or more generations down), the descendant combinator <span class="combinator">..</span> is used.</p><pre><span class="comment">//matches every subject element which is a descendant of note</span><br><span class="selector">note</span> <span class="combinator">..</span> <span class="selector">subject</span> { }</pre>
</div>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.4.3">1.4.3</a></span> Siblings combinator</h4>
		<p>Sibling elements can be accessed via the siblings combinator <span class="combinator">=</span>:</p>
<pre><span class="comment">//matches all the subject elements that are siblings of<br>//the message element(s)</span><br><span class="selector">message</span> <span class="combinator">=</span> <span class="selector">subject</span> { }</pre>
</div>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.4.4">1.4.4</a></span> Next and previous siblings</h4>
		<p>Use the next siblings combinator <span class="combinator">+</span> and previous siblings combinator <span class="combinator">-</span> if you want to access elements following or preceding (in the <em>current</em> tree order) a specified element in the same scope.</p>
<pre><span class="comment">//this will match the message element(s) following a from sibling</span>
<span class="selector">from</span> <span class="combinator">+</span> <span class="selector">message</span> { }
<span class="comment">//this will match the subject element(s) preceding a message sibling</span>
<span class="selector">message</span> <span class="combinator">-</span> <span class="selector">subject</span> { }</pre>
		<p><em>Note:</em> For further instructions on how to select amongst the following or preceding elements read the <a href="#1.5.1">position filters</a> chapter.</p>
</div>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.4.5">1.4.5</a></span> Accessing elements laid out in lines</h4>
		<p><strong>Note:</strong> This section is just the explanation of the very basic idea, and may change soon.</p><p>Containers that are in flow might be laid out in various lines and subjacent line(s) of elements (see 1.x.x Layout of elements in Flow). You can target them by the use of the line combinator.</p><p>It works very similarly to how the <a href="#1.4.6">content text combinator</a> works, but the line combinator uses the vertical bar <span class="combinator">|</span> instead. Placing a pipe selects the lines of elements in a container, selecting as many as you define with the next simple selector. </p>
#TODO link "see 1.x.x etc"
<pre><span class="comment">//this will select all the lines of elements inside of the
//document element</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="selector">*</span> { }
<span class="comment">//this will select only the first line</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="filter">:first</span> { }</pre><p>If you place more pipes, you will drill down into the secondary lines (hierarchically) that have been formed according to the layout algorithm. As before, the universal selector can be omitted between the combinators.</p>
<pre><span class="comment">//this will select all the subjacent lines</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="selector">*</span> <span class="combinator">|</span> <span class="selector">*</span> { }<span class="comment">
//this is equivalent</span>
<span class="selector">document</span> <span class="combinator">||</span> <span class="selector">*</span> { }
<span class="comment">//this will select all the subjacent lines inside of the first
//line of elements</span>
<span class="selector">document</span> <span class="combinator">|</span> <span class="filter">:first</span> <span class="combinator">|</span> <span class="selector">*</span> { }</pre>
#TODO add schema which will illustrate all examples
		<p>Since each line is a somewhat abstract concept - there is no element representing each line, if you create new elements in the scope of a line, only one element per line will be created, and not one per selected element, and it will be attached to the parent element. On the other hand, properties applied in the scope of the line will be applied to all elements in that line. </p><p>The <a href="#1.7.1.2">@parent</a> object will refer to the parent line, in case of a subjacent line, or the parent element, in case of a line.</p>
</div>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.4.6">1.4.6</a></span> Accessing the content text</h4>
		<p>Many times you will want to access a part of an element's content text—a word, or a particular line, for example—rather than its container.</p><p>Consider this snippet of XML code:</p>
<pre class="xml">&lt;<span class="selector">document</span>&gt;
    &lt;<span class="selector">paragraph</span>&gt;This is a line of dummy text. Lorem ipsum
    dolor sit amet, consectetur adipiscing elit.&lt;/<span class="selector">paragraph</span>&gt;
&lt;/<span class="selector">document</span>&gt;</pre>
		<p>First, we have to understand what happens with the content text when it is rendered. An element is represented by a container, think of it as an amount of space in the rendered document and inside it the content text and the containing elements. The default height of the container is the height of its content.</p>
		<p>This is explained in more detail in the chapters about containers and display objects.</p>
		<p>When the width of the container is not wide enough to accommodate all its content text, wrapping occurs. This means that the text is split in various lines of text, and therefore the height increases. Now there are two or more blocks stacked over each other.</p>
		<p>Conceptually, the text can be further split into elements. Each word is preceded, followed, or surrounded by whitespace. Furthermore, each letter or symbol of that word is a separate glyph you can refer to.</p>
		<p><img alt="Graphic explaining the concept of lines, words and glyphs" src="/sites/default/images/spec/accessing_content_text.png"></p>
		<p>To select portions of text, the content text combinator is used. This is a special combinator which has a distinct behavior, that’s why it is not listed among the other combinators. After the combinator, you write a string to specify what part of the text you want to select, or an empty string to select the entire content text.</p>
		<p>You select a portion of the text using a string:</p>
<pre><span class="comment">//this will select any occurrence of “dummy text” and set
//it be 15 points tall</span>
<span class="combinator">..</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="string">“dummy text”</span> { <span class="property">height</span>: <span class="number">15</span> }
<span class="comment">//this will only match the first one</span>
<span class="combinator">..</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="string">“dummy text”</span><span class="filter">:first</span> { <span class="property">height</span>: <span class="number">15</span> }</pre>
		<p>The entire content text is selected if you use the universal selector (actually just selects all lines):</p><pre><span class="comment">//this will select the entire content text of the snippet element</span>
<span class="selector">document</span> <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span> { }</pre><p>You can also select elements by its type. This selects content text elements regardless of what characters actually are contained, and allows you to access any line, word or glyph.</p><p>To access a line, the universal selector is used after the content text combinator as well, but you filter them to point to that particular line:</p><pre><span class="comment">//this will select the first line of text</span>
<span class="selector">document</span> <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:first</span> {}</pre>
		<p>The content filter <span class="filter"><a name="cf_each">:each</a></span> permits the separation of each text elements (either lines, words or glyphs) that would otherwise be joined in the same selection:</p>
<pre><span class="comment">//this will select each line of text and give it vertical margin,
//increasing the line spacing</span>
<span class="selector">document</span> <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:each</span> { <span class="property">margin</span>: <span class="number">5</span> top, <span class="number">5</span> bottom }</pre>
		<p>To access a word, you use the content text combinator and universal selector again, after selecting a portion of the text:</p><pre><span class="selector">document</span>
{
&nbsp;&nbsp;&nbsp; <span class="comment">//this will select the last word of the content text</span>
&nbsp;&nbsp;&nbsp; <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:last</span> { }
&nbsp;&nbsp;&nbsp; <span class="comment">//this is equivalent, since the universal selector can be
&nbsp;&nbsp;&nbsp; //omitted in this case</span>
&nbsp;&nbsp;&nbsp; <span class="selector">paragraph</span> <span class="combinator">&gt;&gt;</span> <span class="filter">:last</span> { }
}</pre>
		<p>You repeat the same pattern again to select a glyph:</p><pre><span class="selector">document</span>
{
&nbsp;&nbsp;&nbsp; <span class="comment">//this will select the first letter of the content text</span>
&nbsp;&nbsp;&nbsp; <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span><span class="filter">:first</span> { }
&nbsp;&nbsp;&nbsp; <span class="comment">//this is equivalent</span>
&nbsp;&nbsp;&nbsp; <span class="selector">paragraph</span> <span class="combinator">&gt;&gt;&gt;</span> <span class="filter">:first</span> { }
}</pre>
		<p>What actually happens when you select a portion of the content text is that an inline element is created, by the use of style rules. If the selected text is adjacent, this inline element spans across all the selected text, creating one addressable container per selection, unless the <a href="#cf_each">each filter</a> is used. In that case, or when the selected portions of the text are not contiguous, one inline element is created per matching text element.</p>
<pre><span class="selector">document</span>
{
&nbsp;&nbsp;&nbsp; <span class="comment">//this will create one pseudo-element for the first three
    //lines of text</span>
    <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="filter">:nth</span>(<span class="number">1</span>, <span class="number">3</span>) { }
&nbsp;&nbsp;&nbsp; <span class="comment">//this will create three pseudo-elements, one for each line</span>
&nbsp;&nbsp;&nbsp; <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="filter">:nth</span>(<span class="number">1</span>, <span class="number">3</span>)<span class="filter">:each</span> { }
&nbsp;&nbsp;&nbsp; <span class="comment">//there is no need for the each filter on this one, since
    //the lines aren’t adjacent</span>
&nbsp;&nbsp;&nbsp; <span class="selector">paragraph</span> <span class="combinator">&gt;</span> <span class="filter">:odd</span> { }
}</pre>
		<p>These inline elements are very flexible and they can potentially intersect with each other, depending on the styles that are applied to different selections. So, for example, selecting the string <span class="string">“dummy text. Lorem”</span>, giving it some styles, and then selecting <span class="string">“Lorem ipsum”</span>, and applying styles, would result in three separate blocks: one with content <span class="string">“dummy text. “</span> (notice the whitespace), one with content <br><span class="string">“ ipsum”</span> (also with whitespace), and a third one, with content <span class="string">“Lorem”</span>, whose styles are a mix of the first and second one, with the styles of the rule that has been applied last overriding the first one. If anywhere inside of one of the inline&nbsp;elements text wrapping occurs, it is split into two inline elements, both with the same style.</p>
</div>
</section>
<section class="chapter">
		<h3 class="title"><span class="number"><a name="1.5">1.5</a></span> Filters &amp; Flags</h3>
		<p><strong>Filters</strong> are used to reduce or alter the current selection. Each individual element of the selection is checked to see if the condition(s) match(es).</p>
		<p>Always remember that if used alone, the omitted universal selector is actually assumed. Filters can be appended to any other selector even allowing multiple affixed filters. For example, you could do the following:</p>
<pre><span class="comment">//this matches the first occurrence of the note element,
//if it has a child</span>
<span class="selector">note<span class="filter">:first:parent</span></span> { }</pre>
		<p>Keep in mind that the order of the filters will alter the outcome, so if you put the filters of the previous example in reverse order, it will select the <em>first element that has a child</em>, instead of the <em>first element, but only if it has a child</em>.</p>
<pre><span class="comment">//this matches the first of the note elements that have a child</span>
<span class="selector">note<span class="filter">:parent:first</span></span> { }</pre>
		<p>Using <strong>flags</strong> you can apply certain HSS declarations depending on an element's event state. Flags are preceded by <code>::</code> unlike filters which use <code>:</code>.</p>
		<p><em>Note:</em> <a href="#1.5.3">System flags</a> are automatically activated and deactivated: the user has no control over their default behaviour.</p>
<div class="sub">
		<h4 class="title"><span class="number"><a name="1.5.1">1.5.1</a></span> Position filters</h4>
		<p>The following filters are used to select a subset of elements, depending on their position in the <em>current</em> tree order.</p>
		<p>In the case of several matched parents the filters refer to the <strong>combined collection</strong> returned whereas their <em>Child</em> variant to the children's position <strong>inside their own parent</strong>.</p>
		<p>This XML example will be used to illustrate the different position filters:</p>

<pre class="xml">&lt;<span class="selector">note</span>&gt;
	&lt;<span class="selector">to</span>&gt;Peter&lt;/<span class="selector">to</span>&gt;
	&lt;<span class="selector">from</span>&gt;James&lt;/<span class="selector">from</span>&gt;
	&lt;<span class="selector">subject</span>&gt;Reminder&lt;/<span class="selector">subject</span>&gt;
        &lt;<span class="selector">message</span>&gt;The keys are under the doormat.&lt;/<span class="selector">message</span>&gt;
	&lt;<span class="selector">message</span>&gt;Please don’t forget to bring some wine.&lt;/<span class="selector">message</span>&gt;
&lt;/<span class="selector">note</span>&gt;
&lt;<span class="selector">note</span>&gt;
	&lt;<span class="selector">to</span>&gt;Paul&lt;/<span class="selector">to</span>&gt;
	&lt;<span class="selector">from</span>&gt;Julia&lt;/<span class="selector">from</span>&gt;
	&lt;<span class="selector">subject</span>&gt;Rendezvous&lt;/<span class="selector">subject</span>&gt;
	&lt;<span class="selector">message</span>&gt;Meet me at the inn.&lt;/<span class="selector">message</span>&gt;
&lt;/<span class="selector">note</span>&gt;</pre>

		<p>The <strong><a name="f_first">first and firstChild filters</a></strong> match the first element(s).</p>
<pre><span class="comment">//this matches the first <em>to</em> element in our example</span>
note <span class="filter">:first</span> { }
<span class="comment">//this matches the first <em>to</em> elements of each <em>note</em> element in our example</span>
note <span class="filter">:firstChild</span> { }</pre>
		<p>The <strong><a name="f_last">last and lastChild filters</a></strong> match the last element(s).</p>
<pre><span class="comment">//this matches the last element in the second <em>note</em> element</span>
note <span class="filter">:last</span> { }
<span class="comment">//this matches the last element<u>s</u> of each <em>note</em> element</span>
note <span class="filter">:lastChild</span> { }</pre>
		<p>The <strong><a name="f_even">even and evenChild filter</a></strong> select elements whose index is even (the count starts with 1).</p>
<pre><span class="comment">//this matches the <em>from</em> element in the first <em>note</em> element
//but not the one in the second <em>note</em> element (7 isn't even)</span>
note from<span class="filter">:even</span> { }</pre>
		<p>The <strong><a name="f_odd">odd and oddChild filters</a></strong> select elements whose index is odd (the count starts with 1).</p>
<pre><span class="comment">//this matches the 1st <em>to</em> element in our example</span>
note to<span class="filter">:odd</span> { }
<span class="comment">//this matches the 1st <em>to</em> elements of each <em>note</em> element in our example</span>
note to<span class="filter">:oddChild</span> { }</pre>
		<p>The <strong><a name="f_nth">nth and nthChild filters</a></strong> select elements which index matches a number or expression, meets a condition or falls within a given range.</p>
<pre><span class="comment">//this matches the fourth element in the collection</span>
<span class="filter">:nth</span>(<span class="number">4</span>) { }
<span class="comment">//if there are at least 6 elements currently in the collection,
//it matches the element after every 5th one; if not it matches the 5th one</span>
<span class="filter">:nth</span>(<span class="expression">5n + 1</span> | <span class="number">5</span>) { }
<span class="comment">//this matches elements whose index is ≥ 3 in the collection</span>
<span class="filter">:nth</span>(&gt;= <span class="number">3</span>) { }
<span class="comment">//this matches elements whose index is 5, 10 or 15 in the collection</span>
<span class="filter">:nth</span>(<span class="expression">5n</span>, <span class="number">15</span>) { }
<span class="comment">//this matches elements whose index is 1, 2, 3 and &ge; 8 in the collection</span>
<span class="filter">:nth</span>(<span class="number">1</span>, <span class="number">3</span> &amp; <span class="number">8</span>, <span class="number">*</span>) { }</pre>
</div>
#TODO JS
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.2">1.5.2</a></span> Hierarchy filters</h4>
		<p>You can filter elements by their relationship with the other elements in the tree.</p>
		<p>The <strong>parent filter</strong> matches every element that is a parent, which means that it has at least one child. If the element is an ancestor it will always also be a parent.</p>
<pre><span class="comment">//this matches childless elements</span>
!<span class="filter">:parent</span> { }</pre>
		<p>The <strong>has filter</strong> matches every element of which at least one child matches the specified selector. If a number or a condition is given, the amount of children is compared.</p>
<pre><span class="comment">//this matches only elements that are parent of a message element</span>
<span class="filter">:has</span>(<span class="selector">message</span>) { }
<span class="comment">//this matches only elements that have exactly 3 children</span>
<span class="filter">:has</span>(<span class="number">3</span>) { }</pre>
		<p>To match every element of which at least one descendant matches the specified selector you can use the <span class="combinator">..</span> combinator. If a number or a condition is given, the amount of ancestors is compared.</p>
<pre><span class="comment">//this matches only element that are an ancestor of an
//important element</span>
<span class="filter">:has</span>(<span class="selector">.. important</span>) { }
<span class="comment">//this matches only element that have 4 or more ancestors</span>
<span class="filter">:has</span>(.. &gt;= <span class="number">4</span>) { }</pre>
		<p>You can also use the <strong>is filter</strong> to select a particular element in the returned collection(s).</p>
<pre>
<span class="comment">//this will only match the <strong>first sibling(s)</strong> following the <em>from</em> element(s)
//<strong>if</strong> it's a <em>message</em> element</span>
from + <span class="filter">:first</span><span class="filter">:is(<span class="selector">message</span>)</span> { }</pre>
</div>
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.3">1.5.3</a></span> System flags</h4>
<p>You usually want to provide some kind of feedback to the user when he/she is using your site. Targeting elements using flags is an easy way to add interactivity to the site, to create a compelling user experience.</p>
<p>The <a name="s_hover"><strong>hover flag</strong></a> targets only elements that are lying under the mouse pointer.</p><pre><span class="comment">//matches every element which has the mouse over it
//(even nested ones)</span>
<span class="flag">::hover</span> { }</pre>
<p>The <strong>press flag</strong> targets only elements which are lying under the mouse pointer while the primary button is pressed (usually the left one) or during a long-press event (an unreleased touch event).</p><pre><span class="comment">//matches every element which is being pressed</span>
<span class="flag">::press</span> { }</pre>
<p>The <strong>drag flag</strong> targets only elements which are being dragged (multiple elements can be dragged at the same time using a multi-touch interface device).</p><pre><span class="comment">//matches every element that is being dragged</span>
<span class="flag">::drag</span> { }</pre>
<p>The <strong>target flag</strong> targets elements which are a potential landing point for the currently dragged element(s).</p><pre><span class="comment">//matches every element that is a dragging destination of the
//currently dragged element</span>
<span class="flag">::target</span> { }</pre>
<p><em>Note:</em> If you want to match a dragging destination which is currently hovered by a dragged element you just need to append the <a href="#s_hover">hover flag</a>:</p>
<pre><span class="comment">//matches every dragging destination elements when a dragged
//element is over it</span>
<span class="flag">::target::hover</span> { }</pre>
<p>The <strong>focus flag</strong> matches the element that currently receives user input (through tabbing for example).</p>
<pre><span class="comment">//matches every element which receives user input</span>
<span class="flag">::focus</span> { }
<span class="comment">//matches every element that does not receive user input</span>
!<span class="flag">::focus</span> { }</pre>
</div>
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.4">1.5.4</a></span> The attribute filter</h4>
<p>You can filter elements based on their attributes using the <strong>attribute filter</strong>.</p>
<pre>
<span class="comment">//matches elements which have a title attribute</span>
:[title] { }
<span class="comment">//matches elements which have a title AND an href attribute</span>
:[title]:[href] { }
<span class="comment">//matches elements which have a title OR an href attribute</span>
:[title, href] { }
<span class="comment">//which is equivalent to</span>
:[title], :[href] { }</pre>
</div>
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.5">1.5.5</a></span> Text matching filters</h4>
<p>These filters select elements which text—either the content text or the value of the attribute(s)—matches a given string. You can use the sensitive argument to enable the case sensitivity.</p>
<p>The <strong>contains filter</strong> matches elements that contain a given string in the text.</p>
<pre><span class="comment">//matches every element whose content text contains “Reminder”</span>
<span class="filter">:contains</span>(<span class="string">"reminder"</span><span class="string"></span>) { }
<span class="comment">//matches every element whose content text exactly contains “Reminder”</span>
<span class="filter">:contains</span>(<span class="string">"Reminder"</span><span class="string"></span>, sensitive) { }
<span class="comment">//matches every element whose title attribute contains “reminder”</span>
:[title<span class="filter">:contains</span>(<span class="string">"Reminder"</span>)] { }</pre>
<p>The <strong>equals filter</strong> matches elements if the text is equal to a given string.</p>
<pre><span class="comment">//matches every element whose content text is equal to “reminder”</span>
<span class="filter">:equals</span>(<span class="string">“Reminder”</span>) { }</pre>
<p>The <strong>startsWith filter</strong> matches elements if the text starts with a given string.</p><pre><span class="comment">//matches every element whose content text starts with “reminder”</span>
<span class="filter">:startsWith</span>(<span class="string">“Reminder”</span>) { }</pre>
<p>The <strong>endsWith filter</strong> matches elements if the text ends with a given string.</p><pre><span class="comment">//matches every element whose content text ends with “reminder”</span>
<span class="filter">:endsWith</span>(<span class="string">“Reminder”</span>) { }</pre>
<p>The <strong>match filter</strong> uses a regular expression to match elements.</p>
<pre><span class="comment">//matches every element whose content text starts with a number</span>
<span class="filter">:match</span>(<span class="string">/^[0-9]/</span>) { }</pre>
<p>The <strong>noText filter</strong> matches elements which have no content text.</p>
<pre><span class="comment">//matches elements which contain no text</span>
<span class="filter">:noText</span> { }
<span class="comment">//matches every element whose title attribute is empty or inexistent</span>
:[title<span class="filter">:noText</span>] { }</pre>
<p>The <strong>length filter</strong> use a criterion to match elements or compares the length of the text against a given condition.</p>
<pre><span class="comment">//matches every element whose content text’s length is greater
//than 3 characters</span>
<span class="filter">:length</span>(&gt; <span class="number">3</span>) { }
<span class="comment">//matches the element(s) whose content text has the most characters</span>
<span class="filter">:length</span>(max) { }
<span class="comment">//matches the element(s) whose content text has the less characters</span>
<span class="filter">:length</span>(min) { }</pre>
</div>
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.6">1.5.6</a></span> Property filters</h4>
<p>Conditions are used to test whether an element is matched based on its properties.</p>
<p>The computed values are tested against, not the declared ones. For example if you set the height of a container to 50%, the value will be dynamically returned in points.</p>
<pre><span class="comment">//match all elements which are in flow</span>
<span class="selector">*</span>(<span class="property">flow</span> = yes) { }
<span class="comment">//match all elements whose background color is not blue</span>
<span class="selector">*</span>(<span class="property">background</span> != blue) { }
<span class="comment">//match all elements that are taller than 300 and not wider than 400</span>
<span class="selector">*</span>(<span class="property">height</span> &gt; <span class="number">300</span> &amp; <span class="property">width</span> &lt; <span class="number">400</span>) { }</pre>
<p><em>Note:</em> If recursion occurences are detected the condition(s) will be evaluated in one pass thus the value(s) returned will always be the same.</p>
</div>
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.7">1.5.7</a></span> Custom filters</h4>
<p>In HSS it is possible to extend the available filters with your own using the <span class="instruction">#filter</span> instruction. They can also be imported from an external file, as any other part of your HSS code, which enables the creation of custom libraries.</p>
<pre>
#filter firstBlue { (background = blue):first }
<span class="comment">//this is equivalent to :startsWith()</span>
#filter sw(myArg1) { $ >> :first:contains(myArg1) }
<span class="comment">//filter which selects the first or the last element</span>
#filter limit { :first, :last }
<span class="comment">//you must define custom filters before applying them:
//limit's definition must precede wideLimit's one</span>
#filter wideLimit { (width > length):limit }

<span class="filter">:firstBlue</span> { }
<span class="filter">:sw</span>("foo") { }
<span class="filter">:limit</span> { }
<span class="filter">:wideLimit</span> { }
</pre>
</div>
<div class="sub">
<h4 class="title"><span class="number"><a name="1.5.8">1.5.8</a></span> User flags</h4>
#TODO <a href="https://github.com/AXR/Specification/issues/36">Issue 36</a>
</div>
</section>
</div>
<div id="btt"><a href="#toc">table of contents</a></div>
</body>
</html>