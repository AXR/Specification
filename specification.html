<!DOCTYPE html>
<!--

             a  A                                                        
            AM\/MA                                                         
           (MA:MMD                                                         
            :: VD
           ::  º                                                         
          ::                                                              
         ::   **      .A$MMMMND   AMMMD     AMMM6    MMMM  MMMM6             
       6::Z. TMMM    MMMMMMMMMDA   VMMMD   AMMM6     MMMMMMMMM6            
      6M:AMMJMMOD     V     MMMA    VMMMD AMMM6      MMMMMMM6              
      ::  TMMTMC         ___MMMM     VMMMMMMM6       MMMM                   
     MMM  TMMMTTM,     AMMMMMMMM      VMMMMM6        MMMM                  
    :: MM TMMTMMMD    MMMMMMMMMM       MMMMMM        MMMM                   
   ::   MMMTTMMM6    MMMMMMMMMMM      AMMMMMMD       MMMM                   
  :.     MMMMMM6    MMMM    MMMM     AMMMMMMMMD      MMMM                   
         TTMMT      MMMM    MMMM    AMMM6  MMMMD     MMMM                   
        TMMMM8       MMMMMMMMMMM   AMMM6    MMMMD    MMMM                   
       TMMMMMM$       MMMM6 MMMM  AMMM6      MMMMD   MMMM                   
      TMMM MMMM                                                           
     TMMM  .MMM                                         
     TMM   .MMD       ARBITRARY·······XML········RENDERING                           
     TMM    MMA       ====================================                              
     TMN    MM                               
      MN    ZM                       
            MM,

 
      AUTHORS: Miro Keller
      
      COPYRIGHT: ©2011 - All Rights Reserved

      LICENSE: see License.txt file

      WEB: http://axr.vg

      THIS CODE AND INFORMATION ARE PROVIDED "AS IS"
      WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR
      FITNESS FOR A PARTICULAR PURPOSE.

*******************************************************************

      FILE INFORMATION:
      =================
      Last changed: 2011/11/21
      HSS version: 1.0
      Revision: 1


-->


<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>The AXR Specification</title>
	<meta name="author" content="Miro Keller">
	<style>
	
	body
	{
		min-width: 720px;
		font-family: "Century Gothic", "Futura", "Verdana", sans-serif;
		padding: 30px 150px;
		color: #666;
	}
	
	
	.notice
	{
		margin: 20px auto;
		background-color: rgba(153,153,153,0.1);
		padding: 20px;
		border-radius: 15px
	}

	.notice p
	{
		margin: 5px 0;
	}

	.notice strong
	{
		color: red;
	}

	p.center
	{
		text-align: center;
	}

	p > span
	{
		background: #fef3c8;
		padding: 0 2px;
		border: 1px solid #dca992;
		color: #b5471a;
		border-radius: 2px;
		font-family: monospace;
	}
	
	code, pre
	{
		background: #FEF3C8;
		padding: 20px;
		border: 1px solid #DCA992;
		color: #B5471A;
		border-radius: 2px;
		white-space: pre-wrap;       /* css-3 */
		white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
		white-space: -pre-wrap;      /* Opera 4-6 */
		white-space: -o-pre-wrap;    /* Opera 7 */
		word-wrap: break-word;
	}
	
	p code
	{
		padding: 0 2px 2px;
	}

	.comment
	{
		color: #95877e;
	}

	.selector
	{
		color: #fd2f7a;
	}

	.property
	{
		color: #1b8a93;
	}

	.filter
	{
		color: #199013;
	}

	.combinator
	{
		color: #1e97f4;
	}

	.object
	{
		color: #933492;
	}

	.number
	{
		color: #2146fa;
	}

	.string
	{
		color: #fd2716;
	}

	pre .highlighted
	{
		background-color: #fefefe;
	}

	table
	{
		width: 100%;
		border: 1px solid #CCC;
	}

	table th
	{
		background-color: #CCC;
		padding: 10px;
	}


	table th:first-child
	{

	}

	table td
	{
		border: 1px solid #CCC;
		text-align: left;
		padding: 10px;
	}

	pre.xml
	{
		background-color: #d6fcd0;
		border-color: #5bac80;
		color: #498e68;
	}

	ul, #spec ol
	{
		list-style: inside;
		line-height: 1.4;
		margin: 10px;
	}

	ul li, ol li
	{
		color: #666666;
	}
	
	</style>
</head>
<body>
<div id="draft_warning" class="notice">
	<p><strong>Warning!</strong></p>
	<p>This file is an editor’s draft and should not be considered final.</p>
</div>

<h1><span>1</span> Arbitrary XML Rendering Specification</h1>
<section id="hss_syntax">
	<h2><span>1</span> The syntax of HSS</h2>
	<section class="introduction">
		<h3><span>1.1</span> Introduction</h3>
		<p>HSS stands for Hierarchical Style Sheets and it is the language used to instruct the AXR renderer how the various elements in the document should look like, how they are laid out and, to some extent, how they behave. The syntax of this language is inspired in CSS, but extending and altering it in various ways, to achieve powerful new ways of creating a web document. Therefore, HSS is not compatible with existing CSS files.</p>
		<p class="center"><img src="http://axr.vg/resources/axr/images/spec/hss_logo.jpg" alt="Hierarchical Style Sheets - Advanced UX Language" /></p>
		<p>HSS inherits the simplicity and clarity of CSSʼ syntax, but stops being a static language, bearing more similarity in some areas to other programming languages. The primary premise for this is the realization that a web page isnʼt a simple hyperlinked text document anymore, but an interactive software, which presents itself to the user through an interface and performs some logic, which may or not be displaying a text document. With this in mind, and the environment in which the document will be accessed (a computing device with an arbitrary display size), it is clear that some sort of interface programming language is needed which is able to express relationships and behaviors, and allows advanced interactivity and layout.</p><p>HSS files are plain-text files, and thus can be edited by any text editor on any platform, although some of its features are better put to use through a visual editing tool, since using code in those cases is less intuitive.</p>
	</section>
	
	<section class="primary_building_blocks">
		<h3><span>1.2</span> The primary building blocks</h3>
		<h4><span>1.2.1</span> Rules</h4>
			<p>One of the most basic concepts in HSS is the notion of rules. A rule is the combination of a selector and a block, which starts with an opening curly brace <code>{</code> and ends with a closing one <code>}</code>, and may contain property definitions and/or other rules.</p>			
<pre><span class="selector">selector</span>
{
	<span class="property">property definitions</span> ;
}</pre>

		<h4><span>1.2.2</span> Selectors</h4>
		<p>Selectors are used to point to a certain element(s) of the document, so that the properties defined inside of the block get applied to them. You define a search pattern and all applicable elements will be searched to see if their properties match the defined conditions. If so, the property definitions are applied.</p>
		<p>Simple selectors are the element name or universal selector, combined with any filter applied to it. A series of simple selectors joined by combinators is called the selector chain or simply selector.</p>
		<p>Some examples:</p>
<pre><span class="comment">//select elements with name “document”</span>
<span class="selector">document</span> { }
<span class="comment">//select the first element with name “book”</span>
<span class="selector">book</span><span class="filter">:first</span> { }
<span class="comment">//select the elements with name “content” that occur after “title”
//elements, which are descendants of “book” elements, which itself
//is a child of “books”</span>
<span class="selector">books book</span> <span class="combinator">..</span> <span class="selector">title</span> <span class="combinator">+</span><span class="combinator"></span> <span class="selector">content</span> { }</pre>

		<h4><span>1.2.3</span> Properties</h4>
		<p>Each element in the document has certain amount of properties, which you can define using property definitions. They are contained within the block that follows a selector chain.</p>
		<p>To write a property declaration simply place the name of the property, followed by a colon and optional whitespace, and then followed by a literal value, an expression, a function or an object. More whitespace can come afterwards, as well. If it is not the last property declaration of the block, it must be ended by a semicolon, to denote that it finishes on that place, and that what follows is something else.</p>
		<p>Here are some examples:</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this makes it 150 points wide</span>
    <span class="property">width</span>: <span class="number">150</span>;
    <span class="comment">//this makes the element 10 points less high as its parent</span>
    <span class="property">height</span>: <span class="number">100%</span> - <span class="number">10</span>;
    <span class="comment">//this aligns the element to the center of its parent element</span>
    <span class="property">alignX</span>: <span class="number">50%</span>;
    <span class="property">alignY</span>: <span class="number">50%</span>;
}

<span class="comment">//in this example the semicolon was ommitted, since it is the
//last element in the block</span>
<span class="selector">document</span> { <span class="property">alignX</span>: <span class="number">50%</span> }</pre>

		<h4><span>1.2.4</span> Objects</h4>
		<p>Objects represent values that are more complex in their nature. Similar to rules, objects have properties which accept values, defined inside a block. Notice the object sign <code>@</code> in front of the object type;</p>
<pre><span class="selector">document</span>
{
    <span class="comment">//this makes the element have rounded corners</span>
    <span class="property">shape</span>: <span class="object">@roundedRect</span> {
        <span class="property">corners</span>: <span class="number">5</span>;
    };
    <span class="comment">//this adds a simple border, 3 points wide and black in color</span>
    <span class="property">border</span>: <span class="object">@lineBorder</span> {
        <span class="property">size</span>: <span class="number">3</span>;
        <span class="property">color</span>: <span class="number">#000</span>;
    };
}</pre>
	</section>
	
	<section class="selectors">
		<h3><span>1.3</span> Selectors</h3>
		<p>Consider the following XML snippet:</p>
<pre class="xml">&lt;<span class="selector">note</span>&gt;
	&lt;<span class="selector">to</span>&gt;Peter&lt;/<span class="selector">to</span>&gt;
	&lt;<span class="selector">from</span>&gt;James&lt;/<span class="selector">from</span>&gt;
	&lt;<span class="selector">subject</span>&gt;Reminder&lt;/<span class="selector">subject</span>&gt;
	&lt;<span class="selector">message</span>&gt;Please don’t forget to bring some &lt;<span class="selector">important</span>&gt;wine &lt;/<span class="selector">important</span>&gt;...&lt;/<span class="selector">message</span>&gt;
&lt;/<span class="selector">note</span>&gt;</pre>

		<p>In the following examples we will be using rules, but without property definitions for clarity.</p>
		<h4><span>1.3.1</span> A simple selector</h4>
		<p>You can target an element by its name. </p>
<pre><span class="comment">//match every note element (within the current scope) and apply
//the style rules declared within the block (in this case none)</span>
<span class="selector">note</span> { }</pre>

		<h4><span>1.3.2</span> Hierarchy</h4>
		<p>Usually what the HSS author does is following the document tree and applying styles to most elements. Rules can be nested inside another rules which will only match descendants of the elements matched by that other selector used by the set. This is what gives HSS its name.</p>
<pre><span class="comment">//match every note element (in the current scope)</span>
<span class="selector">note</span><br />{
	<span class="comment">//match every subject element which is a child of the
	//previously selected note element</span>
	<span class="selector">subject</span> { }
}</pre>

		<h4><span>1.3.3</span> Scope</h4>
		<p>The scope refers to what elements you are targeting by the selector. In the example above, only a subject element that is child of note can be selected, because its scope is restricted to the children of the note element.</p>
		<p>The scope is also reduced using combinators and expanded using grouping.</p>
		
		<h4><span>1.3.4</span> Grouping</h4>
		<p>You can group multiple selectors together, selecting more elements.</p>
<pre><span class="comment">//match every subject element and every message element</span>
<span class="selector">subject</span>, <span class="selector">message</span> { }</pre>

		<h4><span>1.3.5</span> The universal selector</h4>
		<p>The universal selector <span class="selector">*</span> matches every element in the current scope:</p>
<pre><span class="comment">//matches every element that is a child of &lsquo;note&rsquo;</span>
<span class="selector">note</span>
{
&#160;&#160;&#160; <span class="selector">*</span> { }
}</pre>

		<p><em>Note:</em> Since the initial scope is restricted to the root element, using simply the universal selector in the outermost rule set would only select the note element on the example XML code above, unlike what would happen in CSS. To select all elements that are descendants of another you need to use the descendant combinator, and to select all elements altogether you need to start the selector chain with the descendant combinator.</p>
<pre><span class="comment">//matches only the note element</span>
<span class="selector">*</span> { }
<span class="comment">//matches all elements, except the note element</span>
<span class="selector">*</span> <span class="combinator">..</span> <span class="selector">*</span> { }
<span class="comment">//matches all elements</span>
<span class="combinator">..</span> <span class="selector">*</span> { }</pre><p>If the universal selector is not the only part of the selector, like when it has an attribute expression, property expression or a filter (all explained in further chapters), it can be omitted. It may be omitted as well if placed between any combinator other than the child combinator (whitespace), the closest descendants combinator <span class="combinator">.</span>&#160;and the descendants combinator <span class="combinator">..</span>. These are explained in further chapters as well.</p><pre><span class="comment">//the following statements are equivalent</span>
<span class="selector">*</span><span class="filter">:first</span> { }
<span class="filter">:first</span> { }
<span class="comment">//and so are these</span>
<span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> <span class="combinator">&gt;</span> <span class="selector">*</span> { }
<span class="selector">*</span> <span class="combinator">&gt;&gt;</span> <span class="selector">*</span> { }</pre>
		
		<h4><span>1.3.6</span> Negating a selector</h4>
		<p>You can negate any selector by use of the negator <span class="combinator">!</span>, and any of its parts, in the selector chain, meaning that all elements that don’t match the selector will be selected. The name is negated by placing the negator in front of it.</p>
<pre><span class="comment">//this selects the elements which are not note</span>
		<span class="combinator">!</span><span class="selector">note</span> { }</pre><p>Any filter is negated by placing the negator in front of it. The filters are explained in a further chapter.</p><pre><span class="comment">//this selects any note element which is not the first one</span>
		<span class="selector">note</span><span class="combinator">!</span><span class="filter">:first</span> { }
		<span class="comment">//this selects any note element which is not the first one
		//and does not</span><span class="comment"> have a blue background</span>
		<span class="selector">note</span><span class="combinator">!</span><span class="filter">:first</span><span class="combinator">!</span>(<span class="property">background</span>.<span class="property">color</span> = blue) { }</pre><p>If you wanted to negate the entire selector, you place a negator in front of it, but leave a whitespace in between. Only elements in the scope of the last simple selector will be searched.</p><pre><span class="comment">//this matches all elements except the last note</span>
		<span class="combinator">!</span> <span class="selector">note</span><span class="filter">:last</span> {}</pre>
		
		<p class="notice"><strong>FIXME</strong> the syntax for selecting the entire selector is not optimal, I think. <a href="https://github.com/AXR/Specification/issues/4">Issue #4</a></p>
	</section>
</section>
</body>
</html>
